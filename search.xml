<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>通过排列组合问题理解回溯算法</title>
      <link href="/2023/01/18/permutations-and-combinations/"/>
      <url>/2023/01/18/permutations-and-combinations/</url>
      
        <content type="html"><![CDATA[<h2 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h2><div class="note-large notel-blue"><div class="notel-title"><p>Question</p></div><div class="notel-content"><p>给定一个不含重复数字的数组<code>nums</code>，返回其所有可能的元素不重复的全排列。</p> </div></div><p><img lazyload src="/images/loading.svg" data-src="/img/permutations-and-combinations/permutate.png" alt="permutate"></p><p>以数组<code>[1, 2, 3]</code>为例，其总共可能含有的全排列数为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.706ex;" xmlns="http://www.w3.org/2000/svg" width="6.833ex" height="2.605ex" role="img" focusable="false" viewbox="0 -839.4 3020.1 1151.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msubsup"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></g><g data-mml-node="mn" transform="translate(783,369.2) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g><g data-mml-node="mn" transform="translate(783,-296.6) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g></g><g data-mml-node="mo" transform="translate(1464.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(2520.1,0)"><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z"/></g></g></g></svg></mjx-container>个。一般情况下，我们会逐个选择排列中的元素以组成新排列。例如：</p><ul><li><p>首先选择<code>1</code>作为排列的第一位，则第二位可以选择的元素有<code>2</code>和<code>3</code></p></li><li><p>选择<code>2</code>作为排列的第二位，则第三位可以选择的元素仅有<code>3</code></p></li><li><p>选择<code>3</code>作为排列的第三位，则该排列为<code>[1, 2, 3]</code></p></li></ul><p>第三步完成后，由于排列已经形成，此时需要考虑其他可能存在的排列</p><ul><li><p>重新考虑此时排列的第三位，但<code>3</code>已被选过，且无其他选择，回退到上一位</p></li><li><p>重新考虑此时排列的第二位，由于<code>2</code>已被选过，因此可以选择<code>3</code>作为新排列的第二位</p></li><li><p>最后选择<code>2</code>作为新排列的第三位，则该排列为<code>[1,3,2]</code></p></li></ul><p>继续考虑其他可能存在的排列</p><ul><li><p>重新考虑此时排列的第三位，但<code>2</code>已被选过，且无其他选择，回退到上一位</p></li><li><p>重新考虑此时排列的第二位，由于<code>2</code>与<code>3</code>均已被选过，且无其他选择，回退到上一位</p></li><li><p>重新考虑此时排列的第一位，由于<code>1</code>已被选过，可以选择的元素还有<code>2</code>与<code>3</code></p></li><li><p>选择<code>2</code>作为新排列的第一位…</p></li></ul><p><img lazyload src="/images/loading.svg" data-src="/img/permutations-and-combinations/permutate_tree.png" alt="permutate_tree"></p><p>依此规律，我们可以生成所有可能存在的6个排列。将这些排列生成过程以树的形式表示后不难发现，其规律类似于之前提到的DFS算法，因此该问题可以借助DFS算法实现。另外，所谓的“重新考虑”实际上是将排列复原至前一个状态上，尔后重新选择新元素，这种类似“时光倒流”的倒退算法即为著名的<strong>回溯</strong>算法。借助回溯算法，可以解决存在多个步骤且每个步骤有多种实现方法的问题（例如本文的排列与组合问题）。</p><p>首先确定用于生成排列的容器、变量与函数</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于生成排列的主要容器</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums){</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;  <span class="comment">//用于存储所有全排列结果的容器</span></span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; path;  <span class="comment">//用于存储全排列生成步骤（或路径）的容器（即问题分析中所使用的栈）</span></span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">visited</span><span class="params">(n, <span class="number">0</span>)</span></span>;  <span class="comment">//用于存储元素选择状况的容器</span></span><br><span class="line">  <span class="type">int</span> n = nums.<span class="built_in">size</span>();  <span class="comment">//即单个全排列的长度</span></span><br><span class="line">  <span class="built_in">dfs</span>(ans, path, nums, visited, n);  <span class="comment">//DFS算法</span></span><br><span class="line">  <span class="keyword">return</span> ans;  <span class="comment">//主函数最终返回所有全排列结果</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>尔后定义DFS算法的具体内容</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; ans, vector&lt;<span class="type">int</span>&gt;&amp; path, vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; visited, <span class="type">int</span> n)</span></span>{</span><br><span class="line">  <span class="comment">//（确定终止条件）当步骤执行至某全排列的长度等于原数组长度时，该排列生成完毕</span></span><br><span class="line">  <span class="keyword">if</span>(path.<span class="built_in">size</span>() == n){</span><br><span class="line">    ans.<span class="built_in">push_back</span>(path);  <span class="comment">//将该全排列推入结果容器中</span></span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">//并返回</span></span><br><span class="line">  }</span><br><span class="line">  <span class="comment">//用于选择元素的for循环，依次逐个选择元素直至选择完毕</span></span><br><span class="line">  <span class="comment">//在nums包含的n个元素中进行选择</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++){</span><br><span class="line">    <span class="comment">//若某个元素未被选择</span></span><br><span class="line">    <span class="keyword">if</span>(visited[i] == <span class="number">0</span>){</span><br><span class="line">      visited[i] = <span class="number">1</span>;  <span class="comment">//则将其选择，并将其状态设置为已选择</span></span><br><span class="line">      path.<span class="built_in">push_back</span>(nums[i]);  <span class="comment">//将被选择的元素推入步骤容器中（前进）</span></span><br><span class="line">      <span class="built_in">dfs</span>(ans, path, nums, visited, n);  <span class="comment">//并对其执行DFS操作（继续选择该排列的下一位）</span></span><br><span class="line">      path.<span class="built_in">pop_back</span>();  <span class="comment">//该排列生成完毕后将该元素推出容器（回溯）</span></span><br><span class="line">      visited[i] = <span class="number">0</span>;  <span class="comment">//并设置为未选择（便于之后重新选择）</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>其整体运行过程与前文分析部分所展示的过程一致，完整代码为</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; ans, vector&lt;<span class="type">int</span>&gt;&amp; path, vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; visited, <span class="type">int</span> n)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(path.<span class="built_in">size</span>() == n){</span><br><span class="line">      ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++){</span><br><span class="line">      <span class="keyword">if</span>(visited[i] == <span class="number">0</span>){</span><br><span class="line">        visited[i] = <span class="number">1</span>;</span><br><span class="line">        path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="built_in">dfs</span>(ans, path, nums, visited, n);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums){</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">visited</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">dfs</span>(ans, path, nums, visited, n);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><div class="note-large notel-blue"><div class="notel-title"><p>Question</p></div><div class="notel-content"><p>给定两个整数<code>n</code>和<code>k</code>，返回范围 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.753ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2100.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mn" transform="translate(278,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(778,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(1222.7,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1822.7,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g></svg></mjx-container> 中所有可能的<code>k</code>个数的组合。</p> </div></div><p><img lazyload src="/images/loading.svg" data-src="/img/permutations-and-combinations/combine.png" alt="combine"></p><p>以数组<code>[1,2,3]</code>为例，此时若<code>k</code>值为2，则其总共可能含有的组合数为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.685ex;" xmlns="http://www.w3.org/2000/svg" width="6.974ex" height="2.572ex" role="img" focusable="false" viewbox="0 -833.9 3082.4 1136.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msubsup"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"/></g><g data-mml-node="mn" transform="translate(845.3,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mn" transform="translate(748,-287.2) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g></g><g data-mml-node="mo" transform="translate(1526.6,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(2582.4,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g></g></g></svg></mjx-container>个。组合问题与排列问题的区别在于前者不关注于组合内元素的排列顺序，更侧重于分析组合中存在哪些元素。因此，生成组合的过程大致为：</p><ul><li><p>选择<code>1</code>作为组合的第一位，下一个可选元素有<code>2</code>和<code>3</code></p></li><li><p>选择<code>2</code>作为组合的第二位，则该组合为<code>[1, 2]</code></p></li></ul><p>第二步完成后，由于组合已经形成，此时需要考虑其他可能存在的组合</p><ul><li><p>回退至上一位</p></li><li><p>重新选择<code>3</code>作为组合的第二位，则该组合为<code>[1, 3]</code></p></li></ul><p>继续考虑其他可能存在的组合</p><ul><li><p>回退至上一位，发现都已被选过，继续回退</p></li><li><p>重新选择<code>2</code>作为组合的第一位…</p></li></ul><p>依此规律，我们可以生成所有可能存在的6种数组结果，其中包含了3种组合。由此可见，虽然其大致过程与处理排列问题时的流程一致，但在生成过程中难免会产生重复的组合。该生成过程在树结构下可表示为</p><p><img lazyload src="/images/loading.svg" data-src="/img/permutations-and-combinations/combine_tree.png" alt="combine_tree"></p><p>因此，我们需要去除生成结果中的重复组合，即去除上图中冗余组合所属的“枝条”，该过程一般被称为<strong>剪枝</strong>操作。通过剪枝操作，可以保证所生成的组合均不重复。经过剪枝操作后，生成过程被简化为</p><p><img lazyload src="/images/loading.svg" data-src="/img/permutations-and-combinations/combine_tree_2.png" alt="combine_tree_2"></p><p>首先确定用于生成组合的容器、变量与函数</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于生成组合的主要容器</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k){</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;  <span class="comment">//用于存储所有组合结果的容器</span></span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; path;  <span class="comment">//用于存储组合生成步骤（或路径）的容器（即问题分析中所使用的栈）</span></span><br><span class="line">  <span class="built_in">dfs</span>(n, k, start);  <span class="comment">//DFS算法</span></span><br><span class="line">  <span class="keyword">return</span> ans;  <span class="comment">//主函数最终返回所有组合结果</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>尔后定义DFS算法的具体内容</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> start)</span></span>{</span><br><span class="line">  <span class="comment">//（确定终止条件）当步骤执行至某组合的长度等于k时，该组合生成完毕</span></span><br><span class="line">  <span class="keyword">if</span>(path.<span class="built_in">size</span>() == k){</span><br><span class="line">    ans.<span class="built_in">push_back</span>(path); <span class="comment">//将该组合推入结果容器中</span></span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">//并返回</span></span><br><span class="line">  }</span><br><span class="line">  <span class="comment">//用于选择元素的for循环，依次逐个选择元素直至选择完毕</span></span><br><span class="line">  <span class="comment">//从start开始循环实际上为剪枝操作，通过大小关系保证了结果的不重复性</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = start;i &lt;= n;i ++){</span><br><span class="line">    path.<span class="built_in">push_back</span>(i);  <span class="comment">//选择元素推入容器（前进）</span></span><br><span class="line">    <span class="built_in">dfs</span>(n, k, i + <span class="number">1</span>);  <span class="comment">//执行DFS操作（选择下一位）</span></span><br><span class="line">    path.<span class="built_in">pop_back</span>();  <span class="comment">//将元素推出容器（回溯）</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>在该算法中，剪枝操作实际上通过<code>for</code>循环实现，它可以保证后续位的元素一定大于相邻的前一个元素。从组合的生成结果<code>[[1, 2], [1, 3], [2, 3]]</code>不难看出，该结果符合该特征。因此完整代码为</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> start)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(path.<span class="built_in">size</span>() == k){</span><br><span class="line">      ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = start;i &lt;= n;i ++){</span><br><span class="line">      path.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="built_in">dfs</span>(n, k, i + <span class="number">1</span>);</span><br><span class="line">    path.<span class="built_in">pop_back</span>();</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k){</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="built_in">dfs</span>(n, k, <span class="number">1</span>);  <span class="comment">//从1开始选择</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从上述排列与组合的问题中可以发现，这些问题所使用的回溯算法结构类似，大致结构为</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(所需参数)</span></span>{</span><br><span class="line">  <span class="keyword">if</span>(路径终止条件){</span><br><span class="line">    将路径结果推入结果容器中;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = 初始（选择）值; 步骤终止条件; i++){</span><br><span class="line">    path.<span class="built_in">push_back</span>(所处理的对象);</span><br><span class="line">    <span class="built_in">dfs</span>(所需参数);</span><br><span class="line">    path.<span class="built_in">pop_back</span>();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>该结构即经典的回溯算法结构。一般情况下，由于回溯算法与DFS算法及栈结构关系密切，鉴于各个问题的特殊性，该结构中可能会添加<code>visited</code>数组以验证选择情况，或进行剪枝操作等，但该主框架通用于绝大部分可以通过回溯算法处理的问题。</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过“溟痕”理解多源BFS</title>
      <link href="/2023/01/15/sealed-floors/"/>
      <url>/2023/01/15/sealed-floors/</url>
      
        <content type="html"><![CDATA[<div class="note note-yellow icon-padding"><i class="note-icon fa-solid fa-square-question"></i><p>最近打舟肉鸽溟痕关卡“蔓延”时，看到溟痕扩散的方式感觉有点似曾相识，因此有想到如下问题。</p></div><p><img lazyload src="/images/loading.svg" data-src="/img/sealed-floors/sealing.gif" alt="sealing"></p><p>我们假设关卡地板为<code>m*n</code>的网格<code>grid</code>，每个单元格可能存在以下值及其对应状态：</p><ul><li>值为<code>0</code>代表特殊地块，溟痕无法扩散至该地形上</li><li>值为<code>1</code>代表干净地块（即未被扩散）</li><li>值为<code>2</code>代表溟痕地块（即已被扩散）</li></ul><p><img lazyload src="/images/loading.svg" data-src="/img/sealed-floors/default.png" alt="default"></p><p>每过12秒，溟痕会向所在单元格周围四个方向上的相邻单元格扩散。编写算法返回直到<code>grim</code>中不存在干净地块为止所需经过的最小时间。若不可能，则返回<code>-1</code>。</p><div class="note note-blue icon-padding"><i class="note-icon fa-solid fa-file-circle-info"></i><p>备注：PRTS Wiki中关于溟痕扩散机制的解释</p><p><img lazyload src="/images/loading.svg" data-src="/img/sealed-floors/PRTS.png" alt="PRTS"></p></div><p>溟痕会向四个方向<strong>同时</strong>扩散，其扩散方式类似于上一篇“岛屿最大面积问题”中BFS的遍历方式。在“蔓延”关卡中，初始状态下并不存在溟痕地块，仅当溟痕怪通过其自身机制在其所处地块上生成溟痕后，关卡中方才存在第一块溟痕，尔后该溟痕会根据BFS思想向地图中其余地块扩散溟痕。</p><p>但在部分关卡（如SN-EX-6）中，初始状态下即存在多块溟痕地块，这些地块会同时基于BFS对周围地块进行溟痕扩散，此即<strong>多源BFS</strong>。在扩散过程中，为了实时统计场上是否仍存在干净地块，需要在扩散前确定干净地块的数量。同时，由于BFS基于队列运行，所有溟痕地块在进行扩散前需要先入队，并在置于队首时方才进行扩散并出队，因此可以通过该过程对溟痕地块总数进行统计，从而确定该批次即将扩散的溟痕地块总数。每有一个元素入队，则溟痕地块的数量较先前多一块。初次进行溟痕扩散操作时，地块及队列的状态为</p><p><img lazyload src="/images/loading.svg" data-src="/img/sealed-floors/step1.png" alt="step1"></p><p>在队列中仍存在元素时，溟痕地块在扩散过程中若接触到某方向相邻的干净地块，则场上存在的干净地块相应地少一块，同时被扩散的新溟痕地块入队，直至队列被清空（即溟痕地块均扩散完毕且不再有新的溟痕地块生成）。因此，第二次进行溟痕扩散操作时，地块及队列的状态为</p><p><img lazyload src="/images/loading.svg" data-src="/img/sealed-floors/step2.png" alt="step2"></p><p>最终地块与队列的状态为</p><p><img lazyload src="/images/loading.svg" data-src="/img/sealed-floors/step3.png" alt="step3"></p><p>值得注意的是，由于每过12秒溟痕所进行的扩散是<strong>同时</strong>进行的，因此仅在当前批次（即当前层）的溟痕均扩散完毕后，方才将所需时间增加12秒，并进行新入队的溟痕地块的扩散行动。</p><p>首先确认地图中存在的干净地块与溟痕地块的数目，并建立用于溟痕扩散的队列</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> row = grid.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> col = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; que;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">visited</span>(row, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(col, <span class="number">0</span>));</span><br><span class="line"><span class="type">int</span> clean = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> sealed = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; row;i++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; col;j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(grid[i][j] == <span class="number">2</span>)&#123;</span><br><span class="line">      que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(i, j));</span><br><span class="line">      sealed++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">      clean++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>统计完毕后，此时若地图中干净地块与溟痕地块数目均仍为<code>0</code>（即全为特殊地块），则溟痕无法进行扩散，直接返回<code>0</code></p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(sealed == <span class="number">0</span> &amp;&amp; clean == <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>根据队列开始进行溟痕扩散前，对所需时间进行初始化</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TIME 12</span></span><br><span class="line"><span class="type">int</span> time = -TIME;</span><br></pre></td></tr></table></figure></div><p>尔后开始向四个方向进行溟痕扩散，且在队列非空或未接触到边界前该过程会在相应方向上持续</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">  <span class="type">int</span> size = que.<span class="built_in">size</span>();  <span class="comment">//队列长度，即当前待扩散的溟痕地块数目</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">    <span class="type">int</span> x = que.<span class="built_in">front</span>().first;</span><br><span class="line">    <span class="type">int</span> y = que.<span class="built_in">front</span>().second;</span><br><span class="line">    que.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="comment">//向下扩散</span></span><br><span class="line">    <span class="keyword">if</span>(x + <span class="number">1</span> &lt; row)&#123;</span><br><span class="line">      <span class="keyword">if</span>(grid[x + <span class="number">1</span>][y] == <span class="number">1</span>)&#123;</span><br><span class="line">        grid[x + <span class="number">1</span>][y] = <span class="number">2</span>;</span><br><span class="line">        clean--;</span><br><span class="line">        que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(x + <span class="number">1</span>, y));  <span class="comment">//新溟痕地块入队</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向上扩散</span></span><br><span class="line">    <span class="keyword">if</span>(x - <span class="number">1</span> &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(grid[x - <span class="number">1</span>][y] == <span class="number">1</span>)&#123;</span><br><span class="line">        grid[x - <span class="number">1</span>][y] = <span class="number">2</span>;</span><br><span class="line">        clean--;</span><br><span class="line">        que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(x - <span class="number">1</span>, y));  <span class="comment">//新溟痕地块入队</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向右扩散</span></span><br><span class="line">    <span class="keyword">if</span>(y + <span class="number">1</span> &lt; col)&#123;</span><br><span class="line">      <span class="keyword">if</span>(grid[x][y + <span class="number">1</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">        grid[x][y + <span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        clean--;</span><br><span class="line">        que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(x, y + <span class="number">1</span>));  <span class="comment">//新溟痕地块入队</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向左扩散</span></span><br><span class="line">    <span class="keyword">if</span>(y - <span class="number">1</span> &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(grid[x][y - <span class="number">1</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">        grid[x][y - <span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        clean--;</span><br><span class="line">        que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(x, y - <span class="number">1</span>));  <span class="comment">//新溟痕地块入队</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  time += TIME;  <span class="comment">//仅在当前队列清空后，同一层的溟痕均扩散完毕，方才增长时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>队列清空后，若场上不再存在干净地块，则返回溟痕扩散所需总时间，否则返回<code>-1</code></p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(clean == <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> time;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure></div><p>对上述内容进行整合后，完整代码为</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TIME 12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">floorsSealing</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> row = grid.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> col = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; que;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">visited</span>(row, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(col, <span class="number">0</span>));</span><br><span class="line">    <span class="type">int</span> clean = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sealed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; row;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; col;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] == <span class="number">2</span>)&#123;</span><br><span class="line">          que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(i, j));</span><br><span class="line">          sealed++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">          clean++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sealed == <span class="number">0</span> &amp;&amp; clean == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> time = -TIME;</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">      <span class="type">int</span> size = que.<span class="built_in">size</span>();  <span class="comment">//队列长度，即当前待扩散的溟痕地块数目</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x = que.<span class="built_in">front</span>().first;</span><br><span class="line">        <span class="type">int</span> y = que.<span class="built_in">front</span>().second;</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//向下扩散</span></span><br><span class="line">        <span class="keyword">if</span>(x + <span class="number">1</span> &lt; row)&#123;</span><br><span class="line">          <span class="keyword">if</span>(grid[x + <span class="number">1</span>][y] == <span class="number">1</span>)&#123;</span><br><span class="line">            grid[x + <span class="number">1</span>][y] = <span class="number">2</span>;</span><br><span class="line">            clean--;</span><br><span class="line">            que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(x + <span class="number">1</span>, y));  <span class="comment">//新溟痕地块入队</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向上扩散</span></span><br><span class="line">        <span class="keyword">if</span>(x - <span class="number">1</span> &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(grid[x - <span class="number">1</span>][y] == <span class="number">1</span>)&#123;</span><br><span class="line">            grid[x - <span class="number">1</span>][y] = <span class="number">2</span>;</span><br><span class="line">            clean--;</span><br><span class="line">            que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(x - <span class="number">1</span>, y));  <span class="comment">//新溟痕地块入队</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向右扩散</span></span><br><span class="line">        <span class="keyword">if</span>(y + <span class="number">1</span> &lt; col)&#123;</span><br><span class="line">          <span class="keyword">if</span>(grid[x][y + <span class="number">1</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">            grid[x][y + <span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">            clean--;</span><br><span class="line">            que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(x, y + <span class="number">1</span>));  <span class="comment">//新溟痕地块入队</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向左扩散</span></span><br><span class="line">        <span class="keyword">if</span>(y - <span class="number">1</span> &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(grid[x][y - <span class="number">1</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">            grid[x][y - <span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">            clean--;</span><br><span class="line">            que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(x, y - <span class="number">1</span>));  <span class="comment">//新溟痕地块入队</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      time += TIME;  <span class="comment">//仅在当前队列清空后，同一层的溟痕均扩散完毕，方才增长时间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (clean == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> time;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>Python下代码为</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">floorsSealing</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    row, col, time = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>]), <span class="number">0</span></span><br><span class="line">    directions = [(<span class="number">1</span>, <span class="number">0</span>), (-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, -<span class="number">1</span>)]</span><br><span class="line">    queue = []</span><br><span class="line">    <span class="comment">#溟痕地块入队</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row):</span><br><span class="line">      <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(col):</span><br><span class="line">        <span class="keyword">if</span> grid[i][j] == <span class="number">2</span>:</span><br><span class="line">          queue.append((i, j, time))</span><br><span class="line">    <span class="comment">#BFS</span></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">      i, j, time = queue.pop(<span class="number">0</span>)</span><br><span class="line">      <span class="keyword">for</span> di, dj <span class="keyword">in</span> directions:</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= i + di &lt; row <span class="keyword">and</span> <span class="number">0</span> &lt;= j + dj &lt; col <span class="keyword">and</span> grid[i + di][j + dj] == <span class="number">1</span>:</span><br><span class="line">          grid[i + di][j + dj] = <span class="number">2</span></span><br><span class="line">          queue.append((i + di, j + dj, time + <span class="number">12</span>))</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> grid:</span><br><span class="line">      <span class="keyword">if</span> <span class="number">1</span> <span class="keyword">in</span> row: <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> time</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于完美二叉树的指针填充策略</title>
      <link href="/2023/01/14/fill-pointer-of-trees/"/>
      <url>/2023/01/14/fill-pointer-of-trees/</url>
      
        <content type="html"><![CDATA[<div class="note-large notel-blue"><div class="notel-title"><p>Question</p></div><div class="notel-content"><p><img lazyload src="/images/loading.svg" data-src="/img/fill-pointer-of-trees/filled.png" alt="filled"></p><p>给定一个<strong>完美二叉树</strong>，其所有叶子结点均在同一层，且每个父节点均有两个子节点，其定义为</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>编写算法填充其每个<code>next</code>指针，使该指针指向其下一个右侧节点。若不存在下一个右侧节点，则将<code>next</code>指针设置为<code>NULL</code>。缺省状态下，所有<code>next</code>指针均被设置为<code>NULL</code>。</p> </div></div><p>通过分析完美二叉树的结构，可以发现位于该树每一层最右边的结点的<code>next</code>指针均指向<code>NULL</code>，且均为右节点或根结点。因此</p><ul><li>若该层最左侧节点为空，则该层不存在</li><li>若某节点的父节点指向<code>NULL</code>，则该父节点的右节点一定指向<code>NULL</code></li></ul><p>因此，需要通过同时分析两层的状况以进行指针填充操作。即</p><ul><li>父节点的左节点一定指向其右节点</li><li>当父节点的<code>next</code>指针不为空时，其右节点指向该父节点的<code>next</code>指针所指向的节点的左节点</li><li>当父节点的<code>next</code>指针为空时，其右节点也指向<code>NULL</code></li></ul><p>首先，由于指针填充操作需要同时分析两层的状况，因此需要建立反映相邻两层状况的指针<code>cur</code>与<code>pre</code></p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Node* cur = root-&gt;left-&gt;left;</span><br><span class="line">Node* pre = root-&gt;left;</span><br></pre></td></tr></table></figure></div><p>当根节点为空时，直接返回空指针，即</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>当根节点不存在子结点时，直接返回根结点。由于该树为完美二叉树，因此若某节点的左节点或右节点不存在，则该节点的子结点均不存在</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>对于某节点的左节点，其<code>next</code>指针一定指向该结点的右节点，即</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">  root-&gt;left-&gt;next = root-&gt;right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>对于某节点的右节点</p><ul><li>若该右节点的父节点的<code>next</code>指针不为空，则该右节点指向其父节点的<code>next</code>指针所指向的节点的左节点，即</li></ul><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">  root-&gt;right-&gt;next = root-&gt;next-&gt;left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>若该右节点的父节点的<code>next</code>指针为空，则该右节点的<code>next</code>指针亦为空，即</li></ul><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root-&gt;next == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">  root-&gt;right-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>依据此逻辑，可以通过<code>cur</code>指针与<code>pre</code>指针对根结点的后续节点进行指针填充操作。由于父节点的左节点与右节点均存在，因此<code>cur</code>指针需要沿着<code>next</code>指针向右行进，并对该层其他的父节点执行操作。上文提出，若某层最左侧节点为空，则该层不存在。因此，操作的终止条件为<code>cur</code>指针指向<code>NULL</code>或<code>pre</code>指针指向<code>NULL</code>。</p><ul><li>当<code>pre</code>指针指向<code>NULL</code>时，所有<code>cur</code>所在层的节点的父节点均遍历完毕。此时，需要将<code>pre</code>指针与<code>cur</code>指针同时推进至下一层，即</li></ul><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pre = cur;</span><br><span class="line">cur = cur-&gt;left;</span><br></pre></td></tr></table></figure></div><ul><li>当<code>cur</code>指针指向<code>NULL</code>时，<code>cur</code>指针所指节点的左节点不存在，即下一层所有节点均不存在。因此，当前<code>cur</code>指针所在节点为叶子节点，<code>cur</code>指针无法继续前行，整体遍历操作执行完毕</li></ul><p>将上述代码段整合后，完整代码为</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      root-&gt;left-&gt;next = root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* cur = root-&gt;left-&gt;left;</span><br><span class="line">    Node* pre = root-&gt;left;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">      <span class="keyword">while</span>(pre != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        pre-&gt;left-&gt;next = pre-&gt;right;</span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">          pre-&gt;right-&gt;next = pre-&gt;next-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">          pre-&gt;right-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">      pre = cur;</span><br><span class="line">      cur = cur-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>Python下算法为</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="string">&#x27;Node&#x27;</span>:</span><br><span class="line">    pre = root</span><br><span class="line">    <span class="keyword">while</span> pre:</span><br><span class="line">      cur = pre</span><br><span class="line">      <span class="keyword">while</span> cur <span class="keyword">and</span> cur.left:</span><br><span class="line">        cur.left.<span class="built_in">next</span> = cur.right</span><br><span class="line">        <span class="keyword">if</span> cur.<span class="built_in">next</span>:</span><br><span class="line">          cur.right.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.left</span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">      first = first.left</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过BFS/DFS解决岛屿最大面积问题</title>
      <link href="/2023/01/13/island-proportion/"/>
      <url>/2023/01/13/island-proportion/</url>
      
        <content type="html"><![CDATA[<div class="note-large notel-blue"><div class="notel-title"><p>Question</p></div><div class="notel-content"><p><img lazyload src="/images/loading.svg" data-src="/img/island-proportion/default.png" alt="default"></p><p>当前存在一个大小为<code>m*n</code>的二进制矩阵<code>grid</code>，假设<strong>岛屿</strong>是由一些相邻的<code>1</code>构成的组合，即两个<code>1</code>必须在水平或垂直的四个方向上相邻（假设<code>grid</code>外的位置全为<code>0</code>），岛屿的面积即岛上值为<code>1</code>的单元格的数目。计算并返回<code>grid</code>中最大的岛屿面积。若不存在岛屿，则返回面积为<code>0</code>。</p> </div></div><p><img lazyload src="/images/loading.svg" data-src="/img/island-proportion/steps.png" alt="steps"></p><p>由于每个岛屿均被水包围，因此在登陆岛屿后，对岛上的每一寸土地进行递归即可计算当前岛屿面积，最后返回所有岛屿中所得的最大面积即可。登陆岛屿后的具体步骤为</p><ul><li><p>以此时所处位置为中心，向上、下、左、右四个方向前进</p></li><li><p>若发现在该方向前进后抵达的新地点为水或为已抵达过的地点，则停止以该方向前进</p></li><li><p>若发现在该方向前进后抵达的新地点为未抵达过的地点，则在对其进行标记后，重复步骤1</p></li></ul><p>此即<strong>深度优先搜索</strong>方法，该方法实际上将所抵达的点均压至栈中，当新入栈的点抵达边界条件时，该点会在执行完毕后出栈，直至栈被清空。而将执行操作的数据结构从栈替换为队列后，算法会转变为<strong>广度优先搜索</strong>方法，即每次执行操作时均从队首取出所储存的点，并将接下来需要遍历的点置于队尾，直至队列被清空。</p><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>在以<code>grid</code>中每一寸土地为中心进行递归前，需要确定边界终止条件，即遍历位置抵达<code>grid</code>的四个边缘外的时刻。其代码为</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="keyword">if</span>(i == grid.<span class="built_in">size</span>() || i &lt; <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(j == grid[<span class="number">0</span>].<span class="built_in">size</span>() || j &lt; <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>当所抵达的点为陆地时，需要将其标记为已抵达过的点，从而避免后续递归点再次对其进行遍历。因此，可将遍历后的点直接设置为<code>0</code>，此即著名的<strong>沉岛策略</strong>。尔后在对上、下、左、右四个方向上的地点进行递归，并同时统计该岛屿面积。加入边界终止条件后，其代码为</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getProportion</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i == grid.<span class="built_in">size</span>() || i &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (j == grid[<span class="number">0</span>].<span class="built_in">size</span>() || j &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">    grid[i][j] == <span class="number">0</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">getProportion</span>(grid, i + <span class="number">1</span>, j) + <span class="built_in">getProportion</span>(grid, i - <span class="number">1</span>, j) + <span class="built_in">getProportion</span>(grid, i, j + <span class="number">1</span>) + <span class="built_in">getProportion</span>(grid, i, j - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>尔后，通过主函数遍历<code>grid</code>中的每一个点，确定每个岛屿的面积大小，并实时更新最大岛屿面积，完整代码为</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getProportion</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i == grid.<span class="built_in">size</span>() || i &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (j == grid[<span class="number">0</span>].<span class="built_in">size</span>() || j &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">    grid[i][j] == <span class="number">0</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">getProportion</span>(grid, i + <span class="number">1</span>, j) + <span class="built_in">getProportion</span>(grid, i - <span class="number">1</span>, j) + <span class="built_in">getProportion</span>(grid, i, j + <span class="number">1</span>) + <span class="built_in">getProportion</span>(grid, i, j - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">maxProportionOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> maxProportion = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> proportion = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; grid.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">          proportion = <span class="built_in">getProportion</span>(grid, i, j);</span><br><span class="line">          maxProportion = maxProportion &lt; proportion ? proportion : maxProportion;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProportion;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>Python下代码为</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">maxAreaOfIsland</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    maxArea = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getArea</span>(<span class="params">x, y</span>):</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0</span> &lt;= x &lt; <span class="built_in">len</span>(grid) <span class="keyword">and</span> <span class="number">0</span> &lt;= y &lt; <span class="built_in">len</span>(grid[<span class="number">0</span>])):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">      <span class="keyword">if</span> grid[x][y] == <span class="number">1</span>:</span><br><span class="line">        grid[x][y] == <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + getArea(x - <span class="number">1</span>, y) + getArea(x + <span class="number">1</span>, y) + getArea(x, y + <span class="number">1</span>) + getArea(x, y - <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid)):</span><br><span class="line">      <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>])):</span><br><span class="line">        <span class="keyword">if</span> grid[m][n] == <span class="number">1</span>:</span><br><span class="line">          maxArea = <span class="built_in">max</span>(getArea(m, n), maxArea)</span><br><span class="line">    <span class="keyword">return</span> maxArea</span><br></pre></td></tr></table></figure></div><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p> 首先建立队列，并设置操作执行过程中的终止条件。与DFS算法相同，该方法依旧采用<strong>沉岛策略</strong>，并根据队列顺序依次遍历岛屿中的点。</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getArea</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">  queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">  q.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">  <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">int</span> i = t.first, j = t.second, area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i == grid.<span class="built_in">size</span>() || j == grid[<span class="number">0</span>].<span class="built_in">size</span>())&#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[i][j] == <span class="number">0</span>;</span><br><span class="line">    area++;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; grid[i - <span class="number">1</span>][j] == <span class="number">1</span>)&#123;</span><br><span class="line">      q.<span class="built_in">push</span>(&#123;i - <span class="number">1</span>, j&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; grid[i][j - <span class="number">1</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">      q.<span class="built_in">push</span>(&#123;i, j - <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt;= grid.<span class="built_in">size</span>() &amp;&amp; grid[i + <span class="number">1</span>][j] == <span class="number">1</span>)&#123;</span><br><span class="line">      q.<span class="built_in">push</span>(&#123;i + <span class="number">1</span>, j&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j &lt;= grid[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; grid[i][j + <span class="number">1</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">      q.<span class="built_in">push</span>(&#123;i, j + <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>尔后，建立主函数遍历<code>grid</code>中的每个点，其完整代码如下</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> area = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; grid.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">          area = <span class="number">0</span>;</span><br><span class="line">          <span class="built_in">getArea</span>(grid, i, j);</span><br><span class="line">          maxArea = <span class="built_in">max</span>(area, maxArea);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">getArea</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">      <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">      q.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="type">int</span> i = t.first, j = t.second;</span><br><span class="line">      <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i == grid.<span class="built_in">size</span>() || j == grid[<span class="number">0</span>].<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      grid[i][j] == <span class="number">0</span>;</span><br><span class="line">      area++;</span><br><span class="line">      <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; grid[i - <span class="number">1</span>][j] == <span class="number">1</span>)&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;i - <span class="number">1</span>, j&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; grid[i][j - <span class="number">1</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;i, j - <span class="number">1</span>&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(i &lt;= grid.<span class="built_in">size</span>() &amp;&amp; grid[i + <span class="number">1</span>][j] == <span class="number">1</span>)&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;i + <span class="number">1</span>, j&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(j &lt;= grid[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; grid[i][j + <span class="number">1</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;i, j + <span class="number">1</span>&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>Python下代码为</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">maxAreaOfIsland</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getArea</span>(<span class="params">grid, x, y</span>):</span><br><span class="line">      queue = [[x, y]]</span><br><span class="line">      <span class="keyword">while</span> queue:</span><br><span class="line">        [x, y] = queue.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= x &lt; <span class="built_in">len</span>(grid) <span class="keyword">and</span> <span class="number">0</span> &lt;= y &lt; <span class="built_in">len</span>(grid[<span class="number">0</span>]) <span class="keyword">and</span> grid[x][y]:</span><br><span class="line">          grid[x][y] == <span class="number">0</span></span><br><span class="line">          self.area += <span class="number">1</span></span><br><span class="line">          queue += [[x - <span class="number">1</span>, y], [x + <span class="number">1</span>, y], [x, y + <span class="number">1</span>], [x, y - <span class="number">1</span>]]</span><br><span class="line">      <span class="keyword">return</span> self.area</span><br><span class="line">    maxArea = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid)):</span><br><span class="line">      <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>])):</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>):</span><br><span class="line">          self.area = <span class="number">0</span></span><br><span class="line">          maxArea = <span class="built_in">max</span>(getArea(grid, i, j), maxArea)</span><br><span class="line">    <span class="keyword">return</span> maxArea</span><br><span class="line">    </span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过滑动窗口确定无重复字符的最长子串</title>
      <link href="/2023/01/12/slide-window-ascii/"/>
      <url>/2023/01/12/slide-window-ascii/</url>
      
        <content type="html"><![CDATA[<div class="note-large notel-blue"><div class="notel-title"><p>Question</p></div><div class="notel-content"><p>给定一个字符串<code>s</code>，编写算法找出其中不含有重复字符的<strong>最长子串</strong>的长度。</p> </div></div><p>题设要求子串中不出现重复字符，因此可以在遍历过程中将出现过的字符的位置记录在数组中。在出现过的字符再次出现后，当前子串便不再满足条件，因此需要更新子串的起始位置从而重建新子串。</p><p>同时，在遍历过程中还需记录每一步的子串长度，并将其与最长子串长度相比较，若大于最长子串长度则对其进行更新。</p><p><img lazyload src="/images/loading.svg" data-src="/img/slide-window-ascii/steps.png" alt="steps"></p><p>以字符串<code>“abcabc”</code>为例，首先定义用于遍历数组与充当子串尾指针的变量<code>end</code>，以及子串起始指针<code>start</code>。为了避免子串中出现重复字符，定义一个数组<code>index</code>，其具有两个功能</p><ul><li>用于记录字符串中每个字符在之前是否出现过</li><li>用于存储出现重复字符时<code>start</code>应移动到的位置</li></ul><p>其中的127位分别对应ASCII码中的前127位。最后定义用于记录子串当前长度的变量<code>length</code>与子串最大长度<code>max_length</code>。</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> end;</span><br><span class="line"><span class="type">int</span> index[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> max_length = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div><p>对于遍历过程中遍历到的每个字符，定义其<code>index</code>值为<code>end + 1</code>。若某个字符的<code>index</code>值大于<code>start</code>，则说明<code>start</code>值需要更新，即子串中出现了重复字符。此时，在更新子串前，记录当前子串的长度，将其与最大长度比较，并根据比较结果对其进行更新。具体代码如下：</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(end = <span class="number">0</span>;s[end]!=<span class="string">&#x27;\0&#x27;</span>;end++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(index[s[end]] &gt; start)&#123;</span><br><span class="line">    length = end - start;</span><br><span class="line">    <span class="keyword">if</span>(length &gt; max_length)&#123;</span><br><span class="line">      max_length = length;</span><br><span class="line">    &#125;</span><br><span class="line">    start = index[s[end]];  <span class="comment">//更新start</span></span><br><span class="line">  &#125;</span><br><span class="line">  index[s[end]] = end + <span class="number">1</span>;  <span class="comment">//记录字符串中每个字符的index值</span></span><br><span class="line">&#125;</span><br><span class="line">length = end - start;</span><br><span class="line"><span class="keyword">return</span> length&gt;max_length?length:max_length;</span><br></pre></td></tr></table></figure></div><p>依照此逻辑执行操作直至遍历至字符串结尾，其完整代码如下：</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(<span class="type">char</span>* s)</span>&#123;</span><br><span class="line">  <span class="type">int</span> start = <span class="number">0</span>, end, index[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;, length = <span class="number">0</span>, max_length = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(end = <span class="number">0</span>;s[end]!=<span class="string">&#x27;\0&#x27;</span>;end++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(index[s[end]] &gt; start)&#123;</span><br><span class="line">      length = end - start;</span><br><span class="line">      <span class="keyword">if</span>(length &gt; max_length)&#123;</span><br><span class="line">        max_length = length;</span><br><span class="line">      &#125;</span><br><span class="line">      start = index[s[end]];  <span class="comment">//更新start</span></span><br><span class="line">    &#125;</span><br><span class="line">    index[s[end]] = end + <span class="number">1</span>;  <span class="comment">//记录字符串中每个字符的index值</span></span><br><span class="line">  &#125;</span><br><span class="line">  length = end - start;</span><br><span class="line">  <span class="keyword">return</span> length&gt;max_length?length:max_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>Python下代码如下</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    max_length = <span class="number">0</span></span><br><span class="line">    start, end = <span class="number">0</span>, <span class="number">0</span> </span><br><span class="line">    <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">      <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> s[start:end]:</span><br><span class="line">        end += <span class="number">1</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        start += s[start:end].index(c) + <span class="number">1</span></span><br><span class="line">        end += <span class="number">1</span></span><br><span class="line">      max_length = <span class="built_in">max</span>(end - start, max_length)</span><br><span class="line">    <span class="keyword">return</span> max_length <span class="keyword">if</span> max_length != <span class="number">0</span> <span class="keyword">else</span> <span class="built_in">len</span>(s)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>​                            </p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组的翻转与轮转</title>
      <link href="/2023/01/08/rotate-array/"/>
      <url>/2023/01/08/rotate-array/</url>
      
        <content type="html"><![CDATA[<div class="note-large notel-blue"><div class="notel-title"><p>Question</p></div><div class="notel-content"><p>当前存在一个数组<code>nums</code>，编写算法将数组中的 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 个元素向右轮转 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g></g></svg></mjx-container> 个位置（<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g></g></svg></mjx-container> 为非负数）。</p> </div></div><p>为了避免直接轮转导致的数组元素覆盖，可以创建新的数组从而将中的元素存储至正确的位置，尔后再将其赋值至原数组中。在轮转过程中，当数组元素向右移动 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g></g></svg></mjx-container> 个位置后，数组末端的 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="9.829ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 4344.3 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mspace" transform="translate(521,0)"/><g data-mml-node="mi" transform="translate(1354.7,0)"><path data-c="6D" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q351 442 364 440T387 434T406 426T421 417T432 406T441 395T448 384T452 374T455 366L457 361L460 365Q463 369 466 373T475 384T488 397T503 410T523 422T546 432T572 439T603 442Q729 442 740 329Q741 322 741 190V104Q741 66 743 59T754 49Q775 46 803 46H819V0H811L788 1Q764 2 737 2T699 3Q596 3 587 0H579V46H595Q656 46 656 62Q657 64 657 200Q656 335 655 343Q649 371 635 385T611 402T585 404Q540 404 506 370Q479 343 472 315T464 232V168V108Q464 78 465 68T468 55T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z"/><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(833,0)"/><path data-c="64" d="M376 495Q376 511 376 535T377 568Q377 613 367 624T316 637H298V660Q298 683 300 683L310 684Q320 685 339 686T376 688Q393 689 413 690T443 693T454 694H457V390Q457 84 458 81Q461 61 472 55T517 46H535V0Q533 0 459 -5T380 -11H373V44L365 37Q307 -11 235 -11Q158 -11 96 50T34 215Q34 315 97 378T244 442Q319 442 376 393V495ZM373 342Q328 405 260 405Q211 405 173 369Q146 341 139 305T131 211Q131 155 138 120T173 59Q203 26 251 26Q322 26 373 103V342Z" transform="translate(1333,0)"/></g><g data-mml-node="mstyle" transform="translate(3243.7,0)"><g data-mml-node="mspace"/></g><g data-mml-node="mstyle" transform="translate(3410.7,0)"><g data-mml-node="mspace"/></g><g data-mml-node="mi" transform="translate(3744.3,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 个元素将移动至数组首端，而剩余元素则向后移动 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="9.829ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 4344.3 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mspace" transform="translate(521,0)"/><g data-mml-node="mi" transform="translate(1354.7,0)"><path data-c="6D" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q351 442 364 440T387 434T406 426T421 417T432 406T441 395T448 384T452 374T455 366L457 361L460 365Q463 369 466 373T475 384T488 397T503 410T523 422T546 432T572 439T603 442Q729 442 740 329Q741 322 741 190V104Q741 66 743 59T754 49Q775 46 803 46H819V0H811L788 1Q764 2 737 2T699 3Q596 3 587 0H579V46H595Q656 46 656 62Q657 64 657 200Q656 335 655 343Q649 371 635 385T611 402T585 404Q540 404 506 370Q479 343 472 315T464 232V168V108Q464 78 465 68T468 55T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z"/><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(833,0)"/><path data-c="64" d="M376 495Q376 511 376 535T377 568Q377 613 367 624T316 637H298V660Q298 683 300 683L310 684Q320 685 339 686T376 688Q393 689 413 690T443 693T454 694H457V390Q457 84 458 81Q461 61 472 55T517 46H535V0Q533 0 459 -5T380 -11H373V44L365 37Q307 -11 235 -11Q158 -11 96 50T34 215Q34 315 97 378T244 442Q319 442 376 393V495ZM373 342Q328 405 260 405Q211 405 173 369Q146 341 139 305T131 211Q131 155 138 120T173 59Q203 26 251 26Q322 26 373 103V342Z" transform="translate(1333,0)"/></g><g data-mml-node="mstyle" transform="translate(3243.7,0)"><g data-mml-node="mspace"/></g><g data-mml-node="mstyle" transform="translate(3410.7,0)"><g data-mml-node="mspace"/></g><g data-mml-node="mi" transform="translate(3744.3,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 个位置。因此，可以通过翻转的方式将数组末端的元素移动至数组首端，而同时数组首端的元素将被翻转至数组末端。以数组<code>[1, 2, 3, 4, 5, 6, 7]</code>为例，其轮转过程为</p><ul><li>将所有数组元素翻转</li></ul><p><img lazyload src="/images/loading.svg" data-src="/img/rotate-array/step1.png" alt="step1"></p><ul><li>翻转<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="17.121ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 7567.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mn" transform="translate(278,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mo" transform="translate(778,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(1222.7,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mspace" transform="translate(1743.7,0)"/><g data-mml-node="mi" transform="translate(2577.3,0)"><path data-c="6D" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q351 442 364 440T387 434T406 426T421 417T432 406T441 395T448 384T452 374T455 366L457 361L460 365Q463 369 466 373T475 384T488 397T503 410T523 422T546 432T572 439T603 442Q729 442 740 329Q741 322 741 190V104Q741 66 743 59T754 49Q775 46 803 46H819V0H811L788 1Q764 2 737 2T699 3Q596 3 587 0H579V46H595Q656 46 656 62Q657 64 657 200Q656 335 655 343Q649 371 635 385T611 402T585 404Q540 404 506 370Q479 343 472 315T464 232V168V108Q464 78 465 68T468 55T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z"/><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(833,0)"/><path data-c="64" d="M376 495Q376 511 376 535T377 568Q377 613 367 624T316 637H298V660Q298 683 300 683L310 684Q320 685 339 686T376 688Q393 689 413 690T443 693T454 694H457V390Q457 84 458 81Q461 61 472 55T517 46H535V0Q533 0 459 -5T380 -11H373V44L365 37Q307 -11 235 -11Q158 -11 96 50T34 215Q34 315 97 378T244 442Q319 442 376 393V495ZM373 342Q328 405 260 405Q211 405 173 369Q146 341 139 305T131 211Q131 155 138 120T173 59Q203 26 251 26Q322 26 373 103V342Z" transform="translate(1333,0)"/></g><g data-mml-node="mstyle" transform="translate(4466.3,0)"><g data-mml-node="mspace"/></g><g data-mml-node="mstyle" transform="translate(4633.3,0)"><g data-mml-node="mspace"/></g><g data-mml-node="mi" transform="translate(4967,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(5789.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(6789.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(7289.4,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g></svg></mjx-container>区间内的元素</li></ul><p><img lazyload src="/images/loading.svg" data-src="/img/rotate-array/step2.png" alt="step2"></p><ul><li>翻转<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="17.347ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 7667.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(278,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mspace" transform="translate(799,0)"/><g data-mml-node="mi" transform="translate(1632.7,0)"><path data-c="6D" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q351 442 364 440T387 434T406 426T421 417T432 406T441 395T448 384T452 374T455 366L457 361L460 365Q463 369 466 373T475 384T488 397T503 410T523 422T546 432T572 439T603 442Q729 442 740 329Q741 322 741 190V104Q741 66 743 59T754 49Q775 46 803 46H819V0H811L788 1Q764 2 737 2T699 3Q596 3 587 0H579V46H595Q656 46 656 62Q657 64 657 200Q656 335 655 343Q649 371 635 385T611 402T585 404Q540 404 506 370Q479 343 472 315T464 232V168V108Q464 78 465 68T468 55T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z"/><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(833,0)"/><path data-c="64" d="M376 495Q376 511 376 535T377 568Q377 613 367 624T316 637H298V660Q298 683 300 683L310 684Q320 685 339 686T376 688Q393 689 413 690T443 693T454 694H457V390Q457 84 458 81Q461 61 472 55T517 46H535V0Q533 0 459 -5T380 -11H373V44L365 37Q307 -11 235 -11Q158 -11 96 50T34 215Q34 315 97 378T244 442Q319 442 376 393V495ZM373 342Q328 405 260 405Q211 405 173 369Q146 341 139 305T131 211Q131 155 138 120T173 59Q203 26 251 26Q322 26 373 103V342Z" transform="translate(1333,0)"/></g><g data-mml-node="mstyle" transform="translate(3521.7,0)"><g data-mml-node="mspace"/></g><g data-mml-node="mstyle" transform="translate(3688.7,0)"><g data-mml-node="mspace"/></g><g data-mml-node="mi" transform="translate(4022.3,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(4622.3,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(5067,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(5889.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(6889.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(7389.4,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g></svg></mjx-container>区间内的元素</li></ul><p><img lazyload src="/images/loading.svg" data-src="/img/rotate-array/step3.png" alt="step3"></p><p>翻转操作本质上为互换操作。因此，需要定义一个临时变量<code>temp</code>用于替换操作。互换函数为</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span>{</span><br><span class="line">  <span class="type">int</span> temp = *a;</span><br><span class="line">  *a = *b, *b = t;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>持有互换函数后，需在翻转函数中确定互换的元素对象。翻转函数为</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> low, <span class="type">int</span> high)</span>{</span><br><span class="line">  <span class="keyword">while</span>(low &lt; high){</span><br><span class="line">    swap(&amp;nums[low], &amp;nums[high]);</span><br><span class="line">    low++;</span><br><span class="line">    high--;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>因此，根据分析结果，轮转函数为</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> k)</span>{</span><br><span class="line">  k %= numsSize;  <span class="comment">//避免k值大于数组长度</span></span><br><span class="line">  reverse(nums, <span class="number">0</span>, numsSize - <span class="number">1</span>);</span><br><span class="line">  reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">  reverse(nums, k, numsSize - <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>完整代码为</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span>{</span><br><span class="line">  <span class="type">int</span> temp = *a;</span><br><span class="line">  *a = *b, *b = t;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> low, <span class="type">int</span> high)</span>{</span><br><span class="line">  <span class="keyword">while</span>(low &lt; high){</span><br><span class="line">    swap(&amp;nums[low], &amp;nums[high]);</span><br><span class="line">    low++;</span><br><span class="line">    high--;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> k)</span>{</span><br><span class="line">  k %= numsSize;</span><br><span class="line">  reverse(nums, <span class="number">0</span>, numsSize - <span class="number">1</span>);</span><br><span class="line">  reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">  reverse(nums, k, numsSize - <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>Python下该算法代码为</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, nums, k</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    k %= n</span><br><span class="line">    nums[:] = nums[::-<span class="number">1</span>]</span><br><span class="line">    nums[:k] = nums[:k][::-<span class="number">1</span>]</span><br><span class="line">    nums[k:] = nums[k:][::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure></div><p>更好的方法为通过<code>slice</code>操作拼接数组</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, nums, k</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    k %= n</span><br><span class="line">    nums[:] = nums[-k:] + nums[:-k]</span><br><span class="line">      </span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用双指针思想解决有序数组的平方排序问题</title>
      <link href="/2023/01/08/square-sort/"/>
      <url>/2023/01/08/square-sort/</url>
      
        <content type="html"><![CDATA[<div class="note-large notel-blue"><div class="notel-title"><p>Question</p></div><div class="notel-content"><p>当前存在一个以非递减顺序排序的整数数组<code>nums</code>，编写算法返回每个数字的平方所组成的新数组，且同样按照非递减顺序排序。</p> </div></div><p>本题最简单的思路即对每个数组元素均平方后的数组进行再排序，其时间复杂度为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.047ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3998.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mi" transform="translate(1054.7,0)"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"/><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278,0)"/><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(778,0)"/></g><g data-mml-node="mo" transform="translate(2332.7,0)"><path data-c="2061" d=""/></g><g data-mml-node="mo" transform="translate(2332.7,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(2721.7,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mo" transform="translate(3609.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>。但由题意可知，有序数组最左端与最右端的元素在平方后均有可能成为最大数，因此可以考虑采用<strong>双指针法</strong>分别对数组中的负数与正数进行处理。</p><p><img lazyload src="/images/loading.svg" data-src="/img/square-sort/step1.png" alt="step1"></p><p>以数列<code>[-7, -3, 2, 3, 11]</code>为例，首先定义两个指针，其中负数指针<code>low</code>指向<code>nums</code>数组起始位置（即最小值位置），正数指针<code>high</code>指向<code>nums</code>数组末尾位置（即最大值位置）。再定义一个辅助新数组<code>result</code>生成的索引指针<code>index</code>，并指向<code>result</code>数组的末尾位置。</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* result = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * numsSize);</span><br><span class="line"><span class="type">int</span> low = <span class="number">0</span>, high = numsSize - <span class="number">1</span>, index = numsSize - <span class="number">1</span>;</span><br></pre></td></tr></table></figure></div><p><img lazyload src="/images/loading.svg" data-src="/img/square-sort/step2.png" alt="step2"></p><p>当<code>high</code>所指元素的平方结果大于<code>low</code>所指元素的平方结果时，将<code>high</code>所指元素的平方结果导入<code>result</code>中<code>index</code>所指位置。同时，<code>high</code>左移至<code>nums</code>的下一位并准备与当前<code>low</code>所指元素进行比较，<code>index</code>左移至<code>result</code>的下一位。</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[low] * nums[low] &lt; nums[high] * nums[high]){</span><br><span class="line">  result[index--] = nums[high] * nums[high--];</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p><img lazyload src="/images/loading.svg" data-src="/img/square-sort/step3.png" alt="step3"></p><p>当<code>low</code>所指元素的平方结果大于<code>high</code>所指元素的平方结果时，将<code>low</code>所指元素的平方结果导入<code>result</code>中<code>index</code>所指位置。同时，<code>low</code>右移至<code>nums</code>的下一位并准备与当前<code>high</code>所指元素进行比较，<code>index</code>左移至<code>result</code>的下一位。</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[low] * nums[low] &gt; nums[high] * nums[high]){</span><br><span class="line">  result[index--] = nums[low] * nums[low++];</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>故最终完整代码为</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">sortedSquares</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span>* returnSize)</span>{</span><br><span class="line">    <span class="type">int</span>* result = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * numsSize);</span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>, high = numsSize - <span class="number">1</span>, index = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high){</span><br><span class="line">        <span class="keyword">if</span>(nums[low] * nums[low] &lt; nums[high] * nums[high]){</span><br><span class="line">            result[index--] = nums[high] * nums[high--];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            result[index--] = nums[low] * nums[low++];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    *returnSize = numsSize;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>Python下代码为</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedSquares</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sorted</span>([i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> nums])</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过快慢指针法定位链表的中间结点</title>
      <link href="/2023/01/07/fast-slow/"/>
      <url>/2023/01/07/fast-slow/</url>
      
        <content type="html"><![CDATA[<div class="note-large notel-blue"><div class="notel-title"><p>Question</p></div><div class="notel-content"><p>给定一个头结点为<code>head</code>的非空单链表，返回链表的中间结点。若存在两个中间结点，则返回第二个中间结点。</p> </div></div><p>链表的不足在于其无法通过下标直接访问特定结点，需要逐个遍历结点以定位特定结点。一般情况下，可以将链表中的数据内容逐个遍历至数组中，从而将链表转化为数组，进而直接输出数组下标为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.781ex;" xmlns="http://www.w3.org/2000/svg" width="5.852ex" height="2.379ex" role="img" focusable="false" viewbox="0 -706.5 2586.7 1051.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mi" transform="translate(220,394) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(255.4,-345) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><rect width="624.3" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(1086.5,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(2086.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container> 的数组元素，但其代码比较繁杂。因此，本题采用更为巧妙的<strong>快慢指针法</strong>。</p><p><img lazyload src="/images/loading.svg" data-src="/img/fast-slow/listnode.PNG" alt="listnode"></p><p>快慢指针法即同时设置一个快指针与一个慢指针对链表进行遍历，其中快指针一次遍历两个结点，慢指针一次遍历一个结点。当快指针最终指向链表末尾或<code>NULL</code>时，慢指针正好指向中间结点位置。</p><p>首先定义一个快指针与一个慢指针</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">slow</span> =</span> head;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">fast</span> =</span> head;</span><br></pre></td></tr></table></figure></div><p>在定义遍历循环前，需要首先确定循环终止条件。当结点数为奇数时，快指针最终会指向链表末尾，因此其循环为</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(fast-&gt;next != <span class="literal">NULL</span>){</span><br><span class="line">  fast = fast-&gt;next-&gt;next;</span><br><span class="line">  slow = slow-&gt;next;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>当结点数为偶数时，慢指针最终会指向<code>NULL</code>，因此其循环为</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(fast != <span class="literal">NULL</span>){</span><br><span class="line">  fast = fast-&gt;next-&gt;next;</span><br><span class="line">  slow = slow-&gt;next;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>故完整结构为</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">middleNode</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">fast</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">slow</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>){</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>Python下代码为</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">middleNode</span>(<span class="params">self, head</span>):</span><br><span class="line">        fast = head</span><br><span class="line">        slow = head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过汉诺塔问题理解递归方法</title>
      <link href="/2023/01/06/hanoi-tower/"/>
      <url>/2023/01/06/hanoi-tower/</url>
      
        <content type="html"><![CDATA[<div class="note-large notel-blue"><div class="notel-title"><p>Question</p></div><div class="notel-content"><p><img lazyload src="/images/loading.svg" data-src="/img/hanoi-tower/step1.png" alt="step1"></p><p>假设存在A、B、C三根杆，汉诺塔问题即需要将位置A上的圆盘全部移动至位置C，在移动过程中每次仅能移动一个圆盘，且三个位置上的圆盘状态始终保持为大盘在下、小盘在上。</p> </div></div><p>假设目标汉诺塔为n阶，当n&#x3D;3时，其正常流程如下：</p><ul><li>将小盘移动至位置C，将中盘移动至位置B</li></ul><p><img lazyload src="/images/loading.svg" data-src="/img/hanoi-tower/step2.png" alt="step2"></p><ul><li>将小盘移动至位置B，将大盘移动至位置C</li></ul><p><img lazyload src="/images/loading.svg" data-src="/img/hanoi-tower/step3.png" alt="step3"></p><ul><li>将小盘移动至位置A，将中盘移动至位置C</li></ul><p><img lazyload src="/images/loading.svg" data-src="/img/hanoi-tower/step4.png" alt="step4"></p><ul><li>将小盘移动至位置C</li></ul><p><img lazyload src="/images/loading.svg" data-src="/img/hanoi-tower/step5.png" alt="step5"></p><p>从该过程中可以发现，汉诺塔问题的大致流程为</p><ul><li>将位置A上除最大圆盘外的n-1个圆盘移动至位置B上</li><li>将最大圆盘移动至位置C上</li><li>将位置B上的剩余圆盘移动至位置C上</li></ul><p>但由于在移动过程中每次仅能移动一个圆盘，因此步骤一的过程为（步骤三同理）</p><ul><li>将位置A上第n-1个圆盘上的n-2个圆盘移动至位置C上</li><li>将第n-1个圆盘移动至位置B上</li><li>将位置C上的剩余圆盘移动至位置B上</li></ul><p>因此，在解决n阶汉诺塔问题前，需要首先解决n-1阶汉诺塔问题。同理，在解决n-1阶汉诺塔问题前，需要首先解决n-2阶汉诺塔问题。如此持续进行会将问题最终转变为一阶汉诺塔问题，即</p><ul><li>将某位置上的一个圆盘移动至另一个位置上</li></ul><p>该操作实际为正常的移动圆盘操作。因此，n阶汉诺塔问题最终被逐渐降阶简化为基础的移动圆盘操作，该过程即计算机算法中的<strong>递归</strong>操作。</p><p>将移动一次圆盘的操作定义为函数<code>move(n, a, b, c)</code>,其中n表示该次操作移动的圆盘数量，a表示起始位置，b表示过渡位置，c表示目标位置，则使用递归解决n阶汉诺塔问题的具体流程可用图表示为</p><p><img lazyload src="/images/loading.svg" data-src="/img/hanoi-tower/process_n.png" alt="process_n"></p><p>当n&#x3D;3时，汉诺塔问题的最终流程可用图表示为</p><p><img lazyload src="/images/loading.svg" data-src="/img/hanoi-tower/process_3.png" alt="process_3"></p><p>由上述流程可知，每阶汉诺塔问题均能使用同一流程解决。因此，函数<code>move(n, a, b, c)</code>具体内容为</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">move</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> a, <span class="type">char</span> b, <span class="type">char</span> c)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c --&gt; %c&quot;</span>, a, c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    move(n<span class="number">-1</span>, a, c, b);</span><br><span class="line">    move(<span class="number">1</span>, a, b, c);</span><br><span class="line">    move(n<span class="number">-1</span>, b, a, c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>因此，使用递归解决汉诺塔问题的完整代码为</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">move</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> a, <span class="type">char</span> b, <span class="type">char</span> c)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c --&gt; %c&quot;</span>, a, c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    move(n - <span class="number">1</span>, a, c, b);</span><br><span class="line">    move(<span class="number">1</span>, a, b, c);</span><br><span class="line">    move(n - <span class="number">1</span>, b, a, c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  move(n, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>Python下算法代码为</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">move</span>(<span class="params">n, a, b, c</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(a, <span class="string">&quot;--&gt;&quot;</span>, c)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        move(n - <span class="number">1</span>, a, c, b)</span><br><span class="line">        move(<span class="number">1</span>, a, b, c)</span><br><span class="line">        move(n - <span class="number">1</span>, b, a, c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">move(<span class="built_in">int</span>(<span class="built_in">input</span>()), <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中的赋值、视图、副本与拷贝</title>
      <link href="/2022/10/19/view-and-copy/"/>
      <url>/2022/10/19/view-and-copy/</url>
      
        <content type="html"><![CDATA[<p>数组对象在创建后会存在唯一标识数组内容的通用标识符（即id值）与其数组内容在内存中的存储地址，通过不同方式创建基于原数组的新数组会在这两个属性的基础上产生不同的结果。</p><h1 id="赋值与无拷贝"><a href="#赋值与无拷贝" class="headerlink" title="赋值与无拷贝"></a>赋值与无拷贝</h1><p>将原数组直接赋值给新数组后，新数组同原数组的标识符与存储地址一致。因此，新数组可以粗略理解为完全通过原数组访问。因此在直接赋值过程中并未创建拷贝。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]])</span><br><span class="line">b = a  <span class="comment"># a直接赋值给b</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a) == <span class="built_in">id</span>(b))  <span class="comment"># True，标识符一致</span></span><br><span class="line"><span class="built_in">print</span>(a.data == b.data)</span><br><span class="line"><span class="comment"># True，在物理内存中指向的存储地址一致</span></span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> b)  <span class="comment"># True，a与b实际上是同一个数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 任一数组的变化会直接同步在其他数组上</span></span><br><span class="line"><span class="built_in">print</span>(a.shape)</span><br><span class="line">b.shape = (<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a.shape == b.shape)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure></div><h1 id="视图与浅拷贝"><a href="#视图与浅拷贝" class="headerlink" title="视图与浅拷贝"></a>视图与浅拷贝</h1><p>在numpy中对原数组(ndarray)进行切片操作或通过<code>view()</code>方法创建视图后，新数组同原数组的存储地址一致但标识符不一致。介于numpy在进行切片操作时直接操作了原数组，产生的新数组虽变更了标识符，但实际将原数组所在内存地址引用并赋值给了新数组，因此新数组仍基于原数组的存储地址进行内容访问。因此，修改新数组中的数据内容会直接影响并同步给原数组，但诸如变形之类的操作则不会。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]])</span><br><span class="line">b = a[:]  <span class="comment"># 创建基于a的切片</span></span><br><span class="line">c = a.view()  <span class="comment"># 创建基于a的视图</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a) == <span class="built_in">id</span>(b) == <span class="built_in">id</span>(c))  <span class="comment"># False，标识符不一致</span></span><br><span class="line"><span class="built_in">print</span>(a.data == b.data == c.data)</span><br><span class="line"><span class="comment"># True，在物理内存中指向的存储地址一致</span></span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> b <span class="keyword">is</span> c)  <span class="comment"># False，a、b、c不是同一个数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对数组进行赋值操作会影响其他数组</span></span><br><span class="line">a[<span class="number">0</span>, <span class="number">2</span>] = <span class="number">4</span></span><br><span class="line"><span class="built_in">print</span>(b[<span class="number">0</span>, <span class="number">2</span>] == c[<span class="number">0</span>, <span class="number">2</span>] == <span class="number">4</span>)  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对数组进行变形操作不会影响其他数组</span></span><br><span class="line"><span class="built_in">print</span>(a.shape)</span><br><span class="line">b.shape = (<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a.shape == b.shape) <span class="comment"># False</span></span><br></pre></td></tr></table></figure></div><h1 id="副本与深拷贝"><a href="#副本与深拷贝" class="headerlink" title="副本与深拷贝"></a>副本与深拷贝</h1><p>对python序列(tuple)或列表(list)等对象进行切片操作、通过<code>deepCopy()</code>方法创建深拷贝或在numpy中通过<code>copy()</code>方法创建副本后，新数组同原数组的存储地址一致与标识符均不一致，两者之间相互独立。介于python进行切片操作时首先调用<code>deepCopy()</code>方法复制了原数组的深拷贝，然后再在该拷贝上进行操作，因此两者互不相关。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">b = a[:]  <span class="comment"># 创建基于a的切片</span></span><br><span class="line">c = a.copy()  <span class="comment"># 创建基于a的副本</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a) == <span class="built_in">id</span>(b) == <span class="built_in">id</span>(c))  <span class="comment"># False，标识符不一致</span></span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> b <span class="keyword">is</span> c)  <span class="comment"># False，a、b、c不是同一个数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对数组进行操作不会影响其他数组</span></span><br><span class="line">a[<span class="number">2</span>] = <span class="number">4</span></span><br><span class="line"><span class="built_in">print</span>(b[<span class="number">2</span>] == <span class="number">4</span> <span class="keyword">or</span> c[<span class="number">2</span>] == <span class="number">4</span>)  <span class="comment"># False</span></span><br></pre></td></tr></table></figure></div><p>python列表(list)对象进行<code>append()</code>操作时，实际进行了直接拷贝。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">num = <span class="number">3</span></span><br><span class="line">list1.append(num)</span><br><span class="line"><span class="built_in">print</span>(list1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(num) == <span class="built_in">id</span>(list1[<span class="number">2</span>]))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure></div><p>因此，若要避免因修改变量值导致的数组数据变化，可通过深拷贝解决。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">num = <span class="number">3</span></span><br><span class="line">list1.append(copy.deepcopy(num))</span><br><span class="line"><span class="built_in">print</span>(list1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(num) == <span class="built_in">id</span>(list1[<span class="number">2</span>]))  <span class="comment"># False</span></span><br></pre></td></tr></table></figure></div><p>值得注意的是，numpy的ndarray对象进行<code>append()</code>操作需要将结果赋给其他的对象，因此经扩展后生成的新数组与原数组无关，所扩展的值与新数组中的对应扩展元素也无关。</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list1 = np.array([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">num = <span class="number">3</span></span><br><span class="line">list2 = np.append(list1, num)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(num) == <span class="built_in">id</span>(list2[<span class="number">2</span>]))  <span class="comment"># False</span></span><br></pre></td></tr></table></figure></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th>操作</th><th>拷贝类型</th><th>标识符</th><th>内存地址</th></tr></thead><tbody><tr><td>直接赋值</td><td>无</td><td>一致</td><td>一致</td></tr><tr><td>numpy切片</td><td>浅拷贝</td><td>不同</td><td>一致</td></tr><tr><td>python切片</td><td>深拷贝</td><td>不同</td><td>不同</td></tr><tr><td><code>view()</code>方法</td><td>浅拷贝</td><td>不同</td><td>一致</td></tr><tr><td><code>copy()</code>方法</td><td>深拷贝</td><td>不同</td><td>不同</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy库的主要使用方法</title>
      <link href="/2022/10/14/numpy/"/>
      <url>/2022/10/14/numpy/</url>
      
        <content type="html"><![CDATA[<p><code>import numpy as np</code></p><h1 id="数组属性"><a href="#数组属性" class="headerlink" title="数组属性"></a>数组属性</h1><ul><li>Numpy数组（即<code>ndarray</code>）的维度称为秩，一维数组的秩为 1，二维数组的秩为 2</li><li>每个线性的数组称为轴（即维度），二维数组相当于两个一维数组，而第一个一维数组中的每个元素又为一个一维数组</li><li>对于一维数组，<code>ndarray.axis</code>值仅为 0；对于二维数组，列轴（纵轴）的<code>ndarray.axis</code>值为 0，行轴（横轴）的<code>ndarray.axis</code>值为 1；对于三维数组，<code>ndarray.axis</code>的值为 0、1、2 时分别对应数组的第一维（第一层数组）、第二维（第二层数组）、第三维（第三层数组），第一层数组的元素是第二层数组，第二层数组的元素是第三层数组<table><thead><tr><th align="left">属性</th><th>说明</th></tr></thead><tbody><tr><td align="left"><code>ndarray.ndim</code></td><td>秩（维度或轴的数量）</td></tr><tr><td align="left"><code>ndarray.shape</code></td><td>数组的维度（比如数组的n行m列）</td></tr><tr><td align="left"><code>ndarray.size</code></td><td>数组元素总数</td></tr><tr><td align="left"><code>ndarray.axis</code></td><td>数组的轴</td></tr><tr><td align="left"><code>ndarray.dtype</code></td><td><code>ndarray</code>对象数据类型</td></tr><tr><td align="left"><code>ndarray.itemsize</code></td><td><code>ndarray</code>对象元素大小（byte）</td></tr><tr><td align="left"><code>ndarray.flags</code></td><td><code>ndarray</code>对象内存信息</td></tr><tr><td align="left"><code>ndarray.real</code></td><td><code>ndarray</code>元素实部</td></tr><tr><td align="left"><code>ndarray.imag</code></td><td><code>ndarray</code>元素虚部</td></tr><tr><td align="left"><code>ndarray.data</code></td><td>实际数组元素缓冲区</td></tr></tbody></table></li></ul><h2 id="dtype"><a href="#dtype" class="headerlink" title="dtype"></a>dtype</h2><p><code>numpy.dtype(&lt;object&gt;, &lt;align&gt;, &lt;copy&gt;)</code></p><ul><li><code>&lt;object&gt;</code>为要转换为的数据类型对象</li><li><code>&lt;align&gt;</code>若为<code>True</code>则填充字段使其类似于C的结构体</li><li><code>&lt;copy&gt;</code>决定复制dtype对象，若为<code>False</code>则为对内置数据类型对象的引用</li><li>字节顺序通过对数据类型预先设定<code>&gt;</code>或<code>&lt;</code>决定，<code>&gt;</code>即大端法（高字节存储在最前的低位地址），<code>&lt;</code>即小端法 (低字节存储在最前的低位地址)<table><thead><tr><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">bool_</td><td align="left">布尔型数据类型（<code>True</code>或<code>False</code>）</td></tr><tr><td align="left">int_</td><td align="left">默认的整数类型（类似于C语言中的long，int32或int64）</td></tr><tr><td align="left">intc</td><td align="left">与C语言中的int类型一致（一般是int32或int64）</td></tr><tr><td align="left">intp</td><td align="left">用于索引的整数类型（类似于C语言中的ssize_t）</td></tr><tr><td align="left">int8</td><td align="left"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="11.063ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4889.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mo" transform="translate(278,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(1056,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"/><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z" transform="translate(1000,0)"/></g><g data-mml-node="mo" transform="translate(2556,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mn" transform="translate(3000.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"/><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z" transform="translate(1000,0)"/></g><g data-mml-node="mo" transform="translate(4500.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>范围内的整数</td></tr><tr><td align="left">int16</td><td align="left"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="15.587ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 6889.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mo" transform="translate(278,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(1056,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"/><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z" transform="translate(1000,0)"/><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(1500,0)"/><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z" transform="translate(2000,0)"/></g><g data-mml-node="mo" transform="translate(3556,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mn" transform="translate(4000.7,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"/><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z" transform="translate(1000,0)"/><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(1500,0)"/><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z" transform="translate(2000,0)"/></g><g data-mml-node="mo" transform="translate(6500.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>范围内的整数</td></tr><tr><td align="left">int32</td><td align="left"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="26.9ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 11889.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mo" transform="translate(278,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(1056,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(500,0)"/><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(1000,0)"/><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z" transform="translate(1500,0)"/><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(2000,0)"/><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z" transform="translate(2500,0)"/><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(3000,0)"/><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(3500,0)"/><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(4000,0)"/><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z" transform="translate(4500,0)"/></g><g data-mml-node="mo" transform="translate(6056,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mn" transform="translate(6500.7,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(500,0)"/><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(1000,0)"/><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z" transform="translate(1500,0)"/><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(2000,0)"/><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z" transform="translate(2500,0)"/><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(3000,0)"/><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(3500,0)"/><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(4000,0)"/><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z" transform="translate(4500,0)"/></g><g data-mml-node="mo" transform="translate(11500.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>范围内的整数</td></tr><tr><td align="left">int64</td><td align="left"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="47.262ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 20889.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mo" transform="translate(278,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(1056,0)"><path data-c="39" d="M352 287Q304 211 232 211Q154 211 104 270T44 396Q42 412 42 436V444Q42 537 111 606Q171 666 243 666Q245 666 249 666T257 665H261Q273 665 286 663T323 651T370 619T413 560Q456 472 456 334Q456 194 396 97Q361 41 312 10T208 -22Q147 -22 108 7T68 93T121 149Q143 149 158 135T173 96Q173 78 164 65T148 49T135 44L131 43Q131 41 138 37T164 27T206 22H212Q272 22 313 86Q352 142 352 280V287ZM244 248Q292 248 321 297T351 430Q351 508 343 542Q341 552 337 562T323 588T293 615T246 625Q208 625 181 598Q160 576 154 546T147 441Q147 358 152 329T172 282Q197 248 244 248Z"/><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"/><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(1000,0)"/><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(1500,0)"/><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(2000,0)"/><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z" transform="translate(2500,0)"/><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(3000,0)"/><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(3500,0)"/><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(4000,0)"/><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(4500,0)"/><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z" transform="translate(5000,0)"/><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(5500,0)"/><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(6000,0)"/><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z" transform="translate(6500,0)"/><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z" transform="translate(7000,0)"/><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(7500,0)"/><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z" transform="translate(8000,0)"/><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(8500,0)"/><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z" transform="translate(9000,0)"/></g><g data-mml-node="mo" transform="translate(10556,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mn" transform="translate(11000.7,0)"><path data-c="39" d="M352 287Q304 211 232 211Q154 211 104 270T44 396Q42 412 42 436V444Q42 537 111 606Q171 666 243 666Q245 666 249 666T257 665H261Q273 665 286 663T323 651T370 619T413 560Q456 472 456 334Q456 194 396 97Q361 41 312 10T208 -22Q147 -22 108 7T68 93T121 149Q143 149 158 135T173 96Q173 78 164 65T148 49T135 44L131 43Q131 41 138 37T164 27T206 22H212Q272 22 313 86Q352 142 352 280V287ZM244 248Q292 248 321 297T351 430Q351 508 343 542Q341 552 337 562T323 588T293 615T246 625Q208 625 181 598Q160 576 154 546T147 441Q147 358 152 329T172 282Q197 248 244 248Z"/><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"/><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(1000,0)"/><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(1500,0)"/><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(2000,0)"/><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z" transform="translate(2500,0)"/><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(3000,0)"/><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(3500,0)"/><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(4000,0)"/><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(4500,0)"/><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z" transform="translate(5000,0)"/><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(5500,0)"/><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(6000,0)"/><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z" transform="translate(6500,0)"/><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z" transform="translate(7000,0)"/><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(7500,0)"/><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z" transform="translate(8000,0)"/><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(8500,0)"/><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z" transform="translate(9000,0)"/></g><g data-mml-node="mo" transform="translate(20500.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>范围内的整数</td></tr><tr><td align="left">uint8</td><td align="left"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.04ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3111.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mn" transform="translate(278,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mo" transform="translate(778,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mn" transform="translate(1222.7,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(500,0)"/><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(1000,0)"/></g><g data-mml-node="mo" transform="translate(2722.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>范围内的无符号整数</td></tr><tr><td align="left">uint16</td><td align="left"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.302ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4111.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mn" transform="translate(278,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mo" transform="translate(778,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mn" transform="translate(1222.7,0)"><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z"/><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(500,0)"/><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(1000,0)"/><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(1500,0)"/><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(2000,0)"/></g><g data-mml-node="mo" transform="translate(3722.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>范围内的无符号整数</td></tr><tr><td align="left">uint32</td><td align="left"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="14.959ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 6611.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mn" transform="translate(278,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mo" transform="translate(778,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mn" transform="translate(1222.7,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"/><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"/><path data-c="39" d="M352 287Q304 211 232 211Q154 211 104 270T44 396Q42 412 42 436V444Q42 537 111 606Q171 666 243 666Q245 666 249 666T257 665H261Q273 665 286 663T323 651T370 619T413 560Q456 472 456 334Q456 194 396 97Q361 41 312 10T208 -22Q147 -22 108 7T68 93T121 149Q143 149 158 135T173 96Q173 78 164 65T148 49T135 44L131 43Q131 41 138 37T164 27T206 22H212Q272 22 313 86Q352 142 352 280V287ZM244 248Q292 248 321 297T351 430Q351 508 343 542Q341 552 337 562T323 588T293 615T246 625Q208 625 181 598Q160 576 154 546T147 441Q147 358 152 329T172 282Q197 248 244 248Z" transform="translate(1000,0)"/><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(1500,0)"/><path data-c="39" d="M352 287Q304 211 232 211Q154 211 104 270T44 396Q42 412 42 436V444Q42 537 111 606Q171 666 243 666Q245 666 249 666T257 665H261Q273 665 286 663T323 651T370 619T413 560Q456 472 456 334Q456 194 396 97Q361 41 312 10T208 -22Q147 -22 108 7T68 93T121 149Q143 149 158 135T173 96Q173 78 164 65T148 49T135 44L131 43Q131 41 138 37T164 27T206 22H212Q272 22 313 86Q352 142 352 280V287ZM244 248Q292 248 321 297T351 430Q351 508 343 542Q341 552 337 562T323 588T293 615T246 625Q208 625 181 598Q160 576 154 546T147 441Q147 358 152 329T172 282Q197 248 244 248Z" transform="translate(2000,0)"/><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(2500,0)"/><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z" transform="translate(3000,0)"/><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(3500,0)"/><path data-c="39" d="M352 287Q304 211 232 211Q154 211 104 270T44 396Q42 412 42 436V444Q42 537 111 606Q171 666 243 666Q245 666 249 666T257 665H261Q273 665 286 663T323 651T370 619T413 560Q456 472 456 334Q456 194 396 97Q361 41 312 10T208 -22Q147 -22 108 7T68 93T121 149Q143 149 158 135T173 96Q173 78 164 65T148 49T135 44L131 43Q131 41 138 37T164 27T206 22H212Q272 22 313 86Q352 142 352 280V287ZM244 248Q292 248 321 297T351 430Q351 508 343 542Q341 552 337 562T323 588T293 615T246 625Q208 625 181 598Q160 576 154 546T147 441Q147 358 152 329T172 282Q197 248 244 248Z" transform="translate(4000,0)"/><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(4500,0)"/></g><g data-mml-node="mo" transform="translate(6222.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>范围内的无符号整数</td></tr><tr><td align="left">uint64</td><td align="left"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="26.271ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 11611.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mn" transform="translate(278,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mo" transform="translate(778,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mn" transform="translate(1222.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z" transform="translate(500,0)"/><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(1000,0)"/><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(1500,0)"/><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(2000,0)"/><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z" transform="translate(2500,0)"/><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(3000,0)"/><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(3500,0)"/><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(4000,0)"/><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z" transform="translate(4500,0)"/><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(5000,0)"/><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z" transform="translate(5500,0)"/><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(6000,0)"/><path data-c="39" d="M352 287Q304 211 232 211Q154 211 104 270T44 396Q42 412 42 436V444Q42 537 111 606Q171 666 243 666Q245 666 249 666T257 665H261Q273 665 286 663T323 651T370 619T413 560Q456 472 456 334Q456 194 396 97Q361 41 312 10T208 -22Q147 -22 108 7T68 93T121 149Q143 149 158 135T173 96Q173 78 164 65T148 49T135 44L131 43Q131 41 138 37T164 27T206 22H212Q272 22 313 86Q352 142 352 280V287ZM244 248Q292 248 321 297T351 430Q351 508 343 542Q341 552 337 562T323 588T293 615T246 625Q208 625 181 598Q160 576 154 546T147 441Q147 358 152 329T172 282Q197 248 244 248Z" transform="translate(6500,0)"/><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(7000,0)"/><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(7500,0)"/><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(8000,0)"/><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(8500,0)"/><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(9000,0)"/><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(9500,0)"/></g><g data-mml-node="mo" transform="translate(11222.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>范围内的无符号整数</td></tr><tr><td align="left">float_</td><td align="left">float64类型的简写</td></tr><tr><td align="left">float16</td><td align="left">半精度浮点数(包括1个符号位，5个指数位，10个尾数位)</td></tr><tr><td align="left">float32</td><td align="left">单精度浮点数(包括1个符号位，8个指数位，23个尾数位)</td></tr><tr><td align="left">float64</td><td align="left">双精度浮点数(包括1个符号位，11个指数位，52个尾数位)</td></tr><tr><td align="left">complex_</td><td align="left">complex128类型的简写（即128位复数）</td></tr><tr><td align="left">complex64</td><td align="left">复数，表示双32位浮点数（实数部分和虚数部分）</td></tr><tr><td align="left">complex128</td><td align="left">复数，表示双64位浮点数（实数部分和虚数部分）</td></tr></tbody></table></li></ul><p>每个内建类型都有一个唯一定义它的字符代码</p><table><thead><tr><th>字符</th><th>对应类型</th></tr></thead><tbody><tr><td>b</td><td>布尔型</td></tr><tr><td>i</td><td>整型（有符号）</td></tr><tr><td>u</td><td>整型（无符号）</td></tr><tr><td>f</td><td>浮点型</td></tr><tr><td>c</td><td>复数浮点型</td></tr><tr><td>m</td><td>timedelta（时间间隔）</td></tr><tr><td>M</td><td>datetime（日期时间）</td></tr><tr><td>O</td><td>Python对象</td></tr><tr><td>S, a</td><td>字符串（byte-）</td></tr><tr><td>U</td><td>Unicode</td></tr><tr><td>V</td><td>原始数据(void)</td></tr></tbody></table><p>比如int8、int16、int32、int64四种数据类型可使用字符’i1’、’i2’、’i4’、’i8’代替</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data1 = np.dtype(<span class="string">'i4'</span>)  <span class="comment"># 相当于int32</span></span><br><span class="line">data2 = np.dtype(<span class="string">'&lt;i2'</span>)  <span class="comment"># 标注小端法</span></span><br></pre></td></tr></table></figure></div><p>或通过dtype定义结构化数据类型（结构体）</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">student = np.dtype([(<span class="string">'name'</span>,<span class="string">'S20'</span>), (<span class="string">'age'</span>, <span class="string">'i1'</span>), (<span class="string">'grade'</span>, <span class="string">'f4'</span>)]) </span><br><span class="line">data = np.array([(<span class="string">'Alice'</span>, <span class="number">21</span>, <span class="number">50</span>),(<span class="string">'Bob'</span>, <span class="number">18</span>, <span class="number">75</span>)], dtype = student) </span><br><span class="line"><span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure></div><p><strong>切换<code>ndarray</code>中每个元素字节的大端与小端</strong><br><code>numpy.ndarray.byteswap(&lt;inplace&gt;)</code></p><ul><li><code>&lt;inplace&gt;</code>默认为<code>False</code>，若为<code>True</code>则就地交换字节</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">8</span>, <span class="number">256</span>, <span class="number">16</span>], dtype=np.int16)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">map</span>(<span class="built_in">hex</span>, a), end=<span class="string">'\n\n'</span>)  <span class="comment"># &lt;map object at 0x7fcad80b4dc0&gt;</span></span><br><span class="line"><span class="built_in">print</span>(a.byteswap(<span class="literal">True</span>), end=<span class="string">'\n\n'</span>)  <span class="comment"># [2048, 1, 4096]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">map</span>(<span class="built_in">hex</span>, a))  <span class="comment"># &lt;map object at 0x7fcae81ce890&gt;</span></span><br></pre></td></tr></table></figure></div><h1 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h1><p><code>numpy.array(&lt;object&gt;, &lt;dtype&gt;, &lt;copy&gt;, &lt;order&gt;, &lt;subok&gt;, &lt;ndmin&gt;)</code></p><ul><li><code>&lt;object&gt;</code>为数组或嵌套的数列</li><li><code>&lt;dtype&gt;</code>决定了数组元素的数据类型、数据大小、数据字节顺序等</li><li><code>&lt;order&gt;</code>决定创建数组的样式，默认为 A（任意方向），同时 C 为行方向，F 为列方向</li><li><code>&lt;subok&gt;</code>默认返回一个与基类类型一致的数组</li><li><code>&lt;ndmin&gt;</code>指定生成数组的最小维度<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr1 = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment"># 一维数组</span></span><br><span class="line">arr2 = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]) <span class="comment"># 二维数组</span></span><br></pre></td></tr></table></figure></div></li></ul><p><strong>从已存在的数组创建新数组</strong><br><code>numpy.asarray(&lt;object&gt;, &lt;dtype&gt;, &lt;order&gt;)</code></p><ul><li><code>&lt;object&gt;</code>为任意形式的输入参数（列表、元组、多维数组等）</li><li><code>&lt;dtype&gt;</code>决定返回数组的数据类型</li><li><code>&lt;order&gt;</code>决定数据在计算机内存中存储元素的顺序，若为’C’则为行优先，为’F’则为列优先<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>)]</span><br><span class="line">a = np.asarray(x, dtype = <span class="built_in">float</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure></div></li></ul><p><strong>接受buffer输入参数，以流的形式读入转化为ndarray对象，从而实现动态数组</strong><br><code>numpy.frombuffer(&lt;buffer&gt;, &lt;dtype&gt;, &lt;count&gt;, &lt;offset&gt;)</code></p><ul><li><code>&lt;buffer&gt;</code>以流的形式读入，可以为任意对象</li><li><code>&lt;dtype&gt;</code>决定返回数组的数据类型</li><li><code>&lt;count&gt;</code>决定读取的数据数量，默认为 -1（读取所有数据）</li><li><code>&lt;offset&gt;</code>决定读取的起始位置，默认为 0</li><li><code>&lt;buffer&gt;</code>为字符串时，Python3默认str为Unicode类型，需转为bytestring（即在原str前加b）<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">b'Kemono'</span> <span class="comment"># 转换为bytestring</span></span><br><span class="line">a = np.frombuffer(s, dtype = <span class="string">'S1'</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure></div></li></ul><p><strong>从可迭代对象中建立ndarray对象，返回一维数组</strong><br><code>numpy.fromiter(&lt;iterable&gt;, &lt;dtype&gt;, &lt;count&gt;)</code></p><ul><li><code>&lt;iterable&gt;</code>为可迭代对象</li><li><code>&lt;dtype&gt;</code>决定返回数组的数据类型</li><li><code>&lt;count&gt;</code>决定读取的数据数量，默认为 -1（读取所有数据）<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>) <span class="comment"># 生成迭代器</span></span><br><span class="line"></span><br><span class="line">x = np.fromiter(it, dtype = <span class="built_in">float</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure></div></li></ul><p><strong>以指定数值范围创建数组</strong><br><code>numpy.arange(&lt;start&gt;, &lt;stop&gt;, &lt;step&gt;, &lt;dtype&gt;)</code></p><ul><li><code>&lt;start&gt;</code>决定序列起始位（缺省为 0）</li><li><code>&lt;stop&gt;</code>决定序列终止位（不包含该位）</li><li><code>&lt;step&gt;</code>决定步长（缺省为 1）</li><li><code>&lt;dtype&gt;</code>决定返回数组的数据类型<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr1 = np.arange(<span class="number">5</span>, dtype = <span class="built_in">float</span>) <span class="comment"># [0. 1. 2. 3. 4.]</span></span><br><span class="line">arr2 = np.arange(<span class="number">10</span>, <span class="number">20</span>, <span class="number">2</span>) <span class="comment"># [10 12 14 16 18]</span></span><br><span class="line"><span class="built_in">print</span>(arr1, arr2)</span><br></pre></td></tr></table></figure></div></li></ul><p><strong>创建一维等差数组</strong><br><code>np.linspace(&lt;start&gt;, &lt;stop&gt;, &lt;num&gt;, &lt;endpoint&gt;, &lt;retstep&gt;, &lt;dtype&gt;)</code></p><ul><li><code>&lt;start&gt;</code>决定序列起始位</li><li><code>&lt;stop&gt;</code>决定序列终止位</li><li><code>&lt;num&gt;</code>决定生成的等步长的样本数量（缺省为 50）</li><li><code>&lt;endpoint&gt;</code>（默认）为<code>True</code>时，序列中包含<code>&lt;stop&gt;</code>值，反之不包含</li><li><code>&lt;retstep&gt;</code>为<code>True</code>时，生成的数组中将显示间距，反之不显示</li><li><code>&lt;dtype&gt;</code>决定返回数组的数据类型<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.linspace(<span class="number">1</span>, <span class="number">1</span>, <span class="number">10</span>)  <span class="comment"># 十个1组成的序列</span></span><br><span class="line">b = np.linspace(<span class="number">10</span>, <span class="number">20</span>, <span class="number">5</span>, endpoint = false, retstep = <span class="literal">True</span>)</span><br><span class="line"><span class="comment"># [10., 12., 14., 16., 18.]</span></span><br></pre></td></tr></table></figure></div></li></ul><p><strong>创建一维等比数组</strong><br><code>np.logspace(&lt;start&gt;, &lt;stop&gt;, &lt;num&gt;, &lt;endpoint&gt;, &lt;base&gt;, &lt;dtype&gt;)</code></p><ul><li><code>&lt;start&gt;</code>决定序列起始位为<code>base ** start</code></li><li><code>&lt;stop&gt;</code>决定序列终止位为<code>base ** stop</code></li><li><code>&lt;num&gt;</code>决定生成的等步长的样本数量（缺省为 50）</li><li><code>&lt;endpoint&gt;</code>（默认）为<code>True</code>时，序列中包含<code>&lt;stop&gt;</code>值，反之不包含</li><li><code>&lt;base&gt;</code>决定序列底数（缺省为 10）</li><li><code>&lt;dtype&gt;</code>决定返回数组的数据类型<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.logspace(<span class="number">1</span>, <span class="number">4</span>, num = <span class="number">4</span>)  <span class="comment"># [10. 100. 1000. 10000.]</span></span><br><span class="line">b = np.logspace(<span class="number">0</span>, <span class="number">5</span>, <span class="number">5</span>, endpoint = <span class="literal">False</span>, base = <span class="number">2</span>)  <span class="comment"># [1. 2. 4. 8. 16.]</span></span><br></pre></td></tr></table></figure></div></li></ul><p><strong>创建一个指定形状与数据类型且未初始化的空数组</strong><br><code>numpy.empty(&lt;shape&gt;, &lt;dtype&gt;, &lt;order&gt;)</code></p><ul><li><code>&lt;shape&gt;</code>为决定数组形状的整数或整数元组</li><li><code>&lt;dtype&gt;</code>决定返回数组的数据类型</li><li><code>&lt;order&gt;</code>决定数据在计算机内存中存储元素的顺序，若为’C’则为行优先，为’F’则为列优先</li><li>数组元素未初始化，因此内容为内存中的随机值</li></ul><p><strong>创建指定大小的以 0 或 1 填充的数组</strong><br><code>numpy.zeros(&lt;shape&gt;, &lt;dtype&gt;, &lt;order&gt;)</code><br><code>numpy.ones(&lt;shape&gt;, &lt;dtype&gt;, &lt;order&gt;)</code></p><ul><li><code>&lt;shape&gt;</code>为决定数组形状的整数或整数元组</li><li><code>&lt;dtype&gt;</code>决定返回数组的数据类型，缺省为浮点数</li><li><code>&lt;order&gt;</code>若为’C’则用于C的行数组，为’F’则用于FORTRAN的列数组<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.empty([<span class="number">3</span>, <span class="number">2</span>], dtype = <span class="built_in">int</span>)  <span class="comment"># 三行两列空二维数组</span></span><br><span class="line">b = np.zeros(<span class="number">2</span>, <span class="number">2</span>)  <span class="comment"># 两行两列全零二维数组</span></span><br><span class="line">c = np.ones(<span class="number">2</span>, <span class="number">2</span>)  <span class="comment"># 两行两列全一二维数组</span></span><br></pre></td></tr></table></figure></div></li></ul><p><strong>创建以1填充对角线元素的二维等长数组（类似单位矩阵）</strong><br><code>np.eye(&lt;column&gt;, &lt;row&gt;, &lt;index&gt;, &lt;dtype&gt;)</code></p><ul><li><code>&lt;column&gt;</code>决定二维数组行数</li><li><code>&lt;row&gt;</code>决定二维数组列数（默认与行数一致）</li><li><code>&lt;index&gt;</code>决定对角线的索引</li><li><code>&lt;dtype&gt;</code>决定数组返回元素的类型</li></ul><p><strong>创建对角数组</strong><br><code>np.diag(&lt;array_like&gt;, &lt;diagonal_position&gt;)</code></p><ul><li><code>&lt;array_like&gt;</code>若为二维数组，则返回<code>&lt;diagonal_position&gt;</code>位置的对角线；若为一维数组，则返回一个<code>&lt;array_like&gt;</code>作为<code>&lt;diagonal_position&gt;</code>位置对角线的二维数组</li><li><code>&lt;diagonal_position&gt;</code>决定对角线位置，若大于 0 则上移，反之下移<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = np.eye(<span class="number">2</span>)  <span class="comment"># 以1填充对角元素的二维两行两列数组</span></span><br><span class="line"></span><br><span class="line">y = np.arange(<span class="number">9</span>).reshape((<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">arr1 = np.diag(y)  <span class="comment"># [0, 4, 8]</span></span><br><span class="line">arr2 = np.diag(y, -<span class="number">1</span>)  <span class="comment"># [3, 7]</span></span><br><span class="line">z = np.diag(np.diag(arr1))  <span class="comment"># 以[0, 4, 8]为对角元素的三行三列对角矩阵</span></span><br></pre></td></tr></table></figure></div></li></ul><p><strong>给定形状的以随机样本 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.778ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2111.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mn" transform="translate(278,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mo" transform="translate(778,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mn" transform="translate(1222.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(1722.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 中的随机元素填充的数组</strong><br><code>np.random.rand(&lt;size&gt;)</code></p><p><strong>给定形状的以服从标准正态分布的一个或一组元素填充的数组</strong><br><code>np.random.randn(&lt;size&gt;)</code> </p><p><strong>给定形状的以给定范围内的随机整数填充的数组</strong><br><code>np.random.randint(&lt;low&gt;, &lt;high&gt;, &lt;size&gt;, &lt;dtype&gt;)</code></p><ul><li><code>&lt;low&gt;</code>决定起始位</li><li><code>&lt;high&gt;</code>决定终止位（不包含），未赋值时整数范围为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.038ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3110.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mn" transform="translate(278,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mo" transform="translate(778,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(1222.7,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(1520.7,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(2005.7,0)"><path data-c="1D464" d="M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z"/></g><g data-mml-node="mo" transform="translate(2721.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li><li><code>&lt;size&gt;</code>决定整数数组形状</li><li><code>&lt;dtype&gt;</code>决定整数类型</li></ul><p><strong>给定形状的以 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.778ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2111.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mn" transform="translate(278,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mo" transform="translate(778,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mn" transform="translate(1222.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(1722.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 范围内的随机浮点数填充的数组</strong><br><code>np.random.random(&lt;size&gt;)</code></p><p><strong>给定形状的以给定一维数组内的元素随机填充的数组</strong><br><code>np.random.choice(&lt;array&gt;, &lt;size&gt;, &lt;replace&gt;, &lt;p&gt;)</code></p><ul><li><code>&lt;array&gt;</code>为给定的一维数组</li><li><code>&lt;size&gt;</code>决定输出数组形状</li><li><code>&lt;replace&gt;</code>决定一维数组中的元素可否被多次选中，默认为<code>True</code></li><li><code>&lt;p&gt;</code>决定一维数组中各元素被选中的概率，形状必须与<code>&lt;array&gt;</code>一致</li></ul><p><strong>以seed值标记特定随机数序列</strong><br><code>np.random.seed(&lt;seed&gt;)</code></p><ul><li>在相同seed值下所生成的随机数序列为同一批</li><li>调用其他方法生成随机数前，调用此方法可通过seed值标记特定随机数序列或采用已通过seed值标记的特定随机数序列</li></ul><h1 id="切片与索引"><a href="#切片与索引" class="headerlink" title="切片与索引"></a>切片与索引</h1><p><strong>通过内置的<code>slice</code>函数从原数组中切割出新数组</strong><br><code>slice(&lt;start&gt;, &lt;stop&gt;, &lt;step&gt;)</code></p><ul><li><code>&lt;start&gt;</code>决定切割起始位</li><li><code>&lt;stop&gt;</code>决定切割终止位</li><li><code>&lt;step&gt;</code>决定切割间隔数值</li><li>Python切片时复制数组并操作，而Numpy切片时直接操作原数组</li></ul><p>或通过冒号分割切片参数<code>start:stop:step</code>进行切片操作</p><p>切片可以通过省略号使得所选元组的长度与数组的维度相同，若在行位置使用省略号，其将返回包含行中元素的ndarray</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">10</span>)</span><br><span class="line">s1 = <span class="built_in">slice</span>(<span class="number">2</span>, <span class="number">7</span>, <span class="number">2</span>) <span class="comment"># 从索引2开始至索引7终止，间隔为2</span></span><br><span class="line">b = a[<span class="number">2</span>:<span class="number">7</span>:<span class="number">2</span>] <span class="comment"># a == b</span></span><br><span class="line"></span><br><span class="line">c = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(c[<span class="number">1</span>,...]) <span class="comment"># 第二行元素</span></span><br><span class="line"><span class="built_in">print</span>(c[...,<span class="number">1</span>:]) <span class="comment"># 第二列及剩下所有列元素</span></span><br></pre></td></tr></table></figure></div><p><strong>返回数组中（沿特定轴）的最大元素与最小元素的索引值</strong><br><code>numpy.argmax(&lt;array&gt;, &lt;axis&gt;)</code><br><code>numpy.argmin(&lt;array&gt;, &lt;axis&gt;)</code></p><p><strong>返回数组中非零元素的索引值</strong><br><code>numpy.nonzero(&lt;array&gt;)</code></p><p><strong>返回数组中满足给定条件的元素</strong><br><code>numpy.extract(&lt;condition&gt;)</code></p><p><strong>返回数组中满足给定条件的元素的索引值</strong><br><code>numpy.where(&lt;condition&gt;)</code></p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">30</span>, <span class="number">40</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">20</span>, <span class="number">10</span>], [<span class="number">50</span>, <span class="number">0</span>, <span class="number">60</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.nonzero(a))  <span class="comment"># (array([0, 0, 1, 1, 2, 2]), array([0, 1, 1, 2, 0, 2]))</span></span><br><span class="line"><span class="built_in">print</span>(np.where(a &gt; <span class="number">35</span>))  <span class="comment"># (array([0, 2, 2]), array([1, 0, 2]))</span></span><br><span class="line"><span class="built_in">print</span>(np.extract(np.mod(a, <span class="number">3</span>) == <span class="number">0</span>, a))  <span class="comment"># [30, 0, 0, 0, 60]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h2 id="整数数组索引"><a href="#整数数组索引" class="headerlink" title="整数数组索引"></a>整数数组索引</h2><p>可以借助切片<code>:</code>或<code>...</code>与索引数组组合</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]])</span><br><span class="line">y = x[[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]] <span class="comment">#[1, 4, 5]</span></span><br><span class="line"></span><br><span class="line">a = x[<span class="number">1</span>:<span class="number">3</span>, <span class="number">1</span>:<span class="number">3</span>] <span class="comment"># [[4, 5], [6, 7]]</span></span><br><span class="line">b = x[<span class="number">1</span>:<span class="number">3</span>, [<span class="number">1</span>, <span class="number">2</span>]] <span class="comment"># a == b</span></span><br><span class="line">c = a[...,<span class="number">1</span>:] <span class="comment"># [[2, 3], [4, 5], [6, 7]]</span></span><br></pre></td></tr></table></figure></div><h2 id="布尔索引"><a href="#布尔索引" class="headerlink" title="布尔索引"></a>布尔索引</h2><p><strong>通过一个布尔数组索引目标数组</strong><br>布尔索引通过布尔运算获取符合指定条件的元素的数组</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"><span class="built_in">print</span>(x[x &gt; <span class="number">5</span>]) <span class="comment"># [6, 7, 8, 9, 10, 11]</span></span><br></pre></td></tr></table></figure></div><p>使用<code>~</code>(取补运算符)过滤<code>NaN</code></p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([np.nan, <span class="number">1</span>, <span class="number">2</span>, np.nan, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(a[~np.isnan(a)]) <span class="comment"># [1. 2. 3. 4. 5.]</span></span><br><span class="line"></span><br><span class="line">b = np.array([<span class="number">1</span>, <span class="number">2</span>+<span class="number">6j</span>, <span class="number">5</span>, <span class="number">3.5</span>+<span class="number">5j</span>])</span><br><span class="line"><span class="built_in">print</span>(a[np.iscomplex(a)]) <span class="comment"># [2+6j, 3.5+5j]</span></span><br></pre></td></tr></table></figure></div><p>存在多个条件时，将条件加以小括号或使用<code>np.logical_and</code>与<code>np.all</code>方法</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x[(x &gt; <span class="number">5</span>) &amp; (x &lt; <span class="number">7</span>)]) <span class="comment"># 条件加小括号分割</span></span><br><span class="line"><span class="built_in">print</span>(x[np.logical_and(x &gt; <span class="number">5</span>, x &lt; <span class="number">7</span>)]) <span class="comment"># 使用np.logical方法</span></span><br><span class="line"><span class="built_in">print</span>(x[np.<span class="built_in">all</span>([x &gt; <span class="number">5</span>, x &lt; <span class="number">7</span>], axis=<span class="number">0</span>)]) <span class="comment"># 使用np.all方法</span></span><br></pre></td></tr></table></figure></div><h2 id="花式索引"><a href="#花式索引" class="headerlink" title="花式索引"></a>花式索引</h2><p><strong>将整数数组的值作为目标数组的某轴下标进行索引</strong><br>对于使用一维整型数组作为索引：</p><ul><li>若目标为一维数组，则索引结果为对应位置元素</li><li>若目标为二维数组，则索引结果为对应下标的行</li><li>将数据复制到新数组中<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(<span class="number">1</span>, <span class="number">9</span>)</span><br><span class="line">a = x[[<span class="number">0</span>, <span class="number">6</span>]] <span class="comment"># [1, 7]</span></span><br><span class="line"></span><br><span class="line">y = np.arange(<span class="number">9</span>).reshape((<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">b = x[[<span class="number">1</span>, <span class="number">0</span>]] <span class="comment"># [[3, 4, 5], [0, 1, 2]]</span></span><br></pre></td></tr></table></figure></div></li></ul><p>传入多个索引数组需使用<code>np.ix_</code>，即输入两个数组产生笛卡尔积的映射关系</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(<span class="number">9</span>).reshape((<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(x[np.ix_([<span class="number">2</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">2</span>])]) <span class="comment"># [[6, 8], [3, 5]]</span></span><br></pre></td></tr></table></figure></div><h1 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h1><p><strong>对不同形状的数组进行数值计算的方式（即矩阵运算）</strong><br>若两个数组 x 与 y 形状相同，即<code>x.shape == y.shape</code>，则 a 与 b 相乘的结果为 a 与 b 数组对位相乘（维数相同且各维度长度相同）</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">b = np.array([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">c = a * b</span><br><span class="line"><span class="built_in">print</span>(c) <span class="comment"># [2, 6, 12, 20]</span></span><br></pre></td></tr></table></figure></div><p>若两个数组 x 与 y 形状不同，即<code>x.shape != y.shape</code>，则将触发广播机制</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>], [<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>], [<span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>]])</span><br><span class="line">b = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(a + b) <span class="comment"># [[0, 1, 2], [10, 11, 12], [20, 21, 22], [30, 31, 32]]</span></span><br></pre></td></tr></table></figure></div><p><strong>返回封装了一数组广播到另一数组的结果，并模仿广播对象</strong><br><code>numpy.broadcast(&lt;arr1&gt;, &lt;arr2&gt;)</code></p><p><strong>将数组广播到新形状，并在原数组上返回只读视图，通常不连续</strong><br><code>numpy.broadcast_to(&lt;array&gt;, &lt;shape&gt;)</code></p><ul><li><code>&lt;array&gt;</code>为原数组</li><li><code>&lt;shape&gt;</code>为新形状</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(<span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>, dtype=<span class="built_in">int</span>)</span><br><span class="line">y = np.array([[<span class="number">1</span>], [<span class="number">3</span>], [<span class="number">5</span>]])</span><br><span class="line"></span><br><span class="line">b = np.broadcast(x, y) <span class="comment"># 返回广播对象</span></span><br><span class="line">row, column = b.iters <span class="comment"># 两个flatiter对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 广播的前两步对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(row), <span class="built_in">next</span>(column)) <span class="comment"># (4, 1)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(row), <span class="built_in">next</span>(column)) <span class="comment"># (4, 3)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">c = np.empty(b.shape) <span class="comment">#3 *3大小的空数组</span></span><br><span class="line">c.flat = [i + j <span class="keyword">for</span> (i,j) <span class="keyword">in</span> b] <span class="comment"># [[5, 7, 9], [6, 8, 10], [7, 9, 11]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.broadcast_to(x, (<span class="number">2</span>, <span class="number">3</span>))) <span class="comment"># [[4, 5, 6], [4, 5, 6]]</span></span><br></pre></td></tr></table></figure></div><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>提供灵活访问一个或多个数组元素的方法，迭代选择顺序与数据内存布局一致，<strong>缺省行序优先</strong><br><code>np.nditer(&lt;array_like&gt;, &lt;flags&gt;, &lt;op_flags&gt;, &lt;order&gt;)</code></p><ul><li><code>&lt;array_like&gt;</code>为需要迭代的序列</li><li><code>&lt;flags&gt;</code>用于控制迭代器行为<table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><code>buffered</code></td><td>在需要时启用缓冲</td></tr><tr><td><code>c_index</code></td><td>跟踪C顺序索引</td></tr><tr><td><code>f_index</code></td><td>跟踪Fortran顺序索引</td></tr><tr><td><code>multi_index</code></td><td>跟踪多个索引或每次迭代跟踪一种索引(多维索引)</td></tr><tr><td><code>external_loop</code></td><td>所给值为具有多个值的一维数组而非零维数组</td></tr></tbody></table></li><li><code>&lt;op_flags&gt;</code>指定每个操作的特征，缺省状态下待迭代数组状态为’read-only’，若在遍历迭代数组的同时修改数组元素则需指定为’readwrite’或’writeonly’</li><li><code>&lt;order&gt;</code>用于控制迭代顺序，’C’为行序优先，’F’为列序优先<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">6</span>).reshape(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代输出数组元素</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a):</span><br><span class="line"><span class="built_in">print</span>(x, end = <span class="string">', '</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'\n'</span>) <span class="comment"># [0, 1, 2, 3, 4, 5,]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代输出转置数组元素</span></span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> np.nditer(a.T):</span><br><span class="line"><span class="built_in">print</span>(y, end = <span class="string">', '</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'\n'</span>) <span class="comment"># [0, 1, 2, 3, 4, 5,]</span></span><br><span class="line"><span class="comment"># y在转置后元素在内存中的存储顺序仍与x一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以行序优先模式迭代输出转置数组的元素</span></span><br><span class="line"><span class="keyword">for</span> z <span class="keyword">in</span> np.nditer(a.T, order = <span class="string">'C'</span>):</span><br><span class="line"><span class="built_in">print</span>(z, end = <span class="string">', '</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'\n'</span>) <span class="comment"># [0, 3, 1, 4, 2, 5,]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改数组元素</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a, op_flags=<span class="string">'readwrite'</span>):</span><br><span class="line">x[...] = <span class="number">2</span>*x</span><br><span class="line"><span class="built_in">print</span>(x) <span class="comment"># [0, 2, 4, 6, 8, 10,]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加索引</span></span><br><span class="line">it = np.nditer(x, flags=[<span class="string">'multi_index'</span>])</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> it.finished:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"%d&lt;%s&gt;"</span>%(it[<span class="number">0</span>], it.multi_index)) <span class="comment">#生成二维index</span></span><br><span class="line">it.iternext() <span class="comment"># 进入下一次迭代</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加外部循环(对应于每列并组合为一维数组)</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(x, flags=[<span class="string">'external_loop'</span>], order=<span class="string">'F'</span>):</span><br><span class="line"><span class="built_in">print</span>(x, end=<span class="string">', '</span>) <span class="comment">#[[0, 2], [4, 6], [8, 10]]</span></span><br></pre></td></tr></table></figure></div></li></ul><p><code>nditer</code>可同时迭代两个可广播数组</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], dtype=<span class="built_in">int</span>)</span><br><span class="line">b = np.arange(<span class="number">0</span>, <span class="number">60</span>, <span class="number">5</span>).reshape(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> x,y <span class="keyword">in</span> np.nditer([a,b]):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'%d:%d'</span> % (x,y), end=<span class="string">', '</span>)</span><br><span class="line"><span class="comment"># 1:0, 2:5, 3:10, 4:15, 1:20, 2:25, 3:30, 4:35, 1:40, 2:45, 3:50, 4:55</span></span><br></pre></td></tr></table></figure></div><h1 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h1><p><strong>在不改变原始数据的情况下修改数组形状</strong><br><code>numpy.reshape(&lt;array&gt;, &lt;newshape&gt;, &lt;order&gt;)</code></p><ul><li><code>&lt;array&gt;</code>为需要修改形状的数组</li><li><code>&lt;newshape&gt;</code>为整数或整数数组（应兼容原数组形状）</li><li><code>&lt;order&gt;</code>决定元素的排列顺序<table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>‘C’</td><td>按行排列</td></tr><tr><td>‘F’</td><td>按列排列</td></tr><tr><td>‘A’</td><td>按数组原顺序排列</td></tr><tr><td>‘K’</td><td>按元素在内存中的存储顺序排列</td></tr></tbody></table></li></ul><p><strong>对数组中各元素进行处理（数组元素迭代器）</strong><br><code>numpy.ndarray.flat()</code></p><p><strong>返回一份展开的数组拷贝并独立于原数组</strong><br><code>numpy.ndarray.flatten(&lt;order&gt;)</code></p><ul><li><code>&lt;order&gt;</code>决定元素的排列顺序（同<code>reshape()</code>）</li><li>对拷贝所进行的修改不会影响原数组</li></ul><p><strong>返回一份展开的数组视图</strong><br><code>numpy.ravel(&lt;array&gt;, &lt;order&gt;)</code></p><ul><li><code>&lt;array&gt;</code>为需要进行操作的数组</li><li><code>&lt;order&gt;</code>决定元素的排列顺序（同<code>reshape()</code>）</li><li>对视图进行的修改会影响原数组<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> elements <span class="keyword">in</span> a.flat:</span><br><span class="line"><span class="built_in">print</span>(element) <span class="comment">#依次输出数组中元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按列优先顺序展开数组</span></span><br><span class="line"><span class="built_in">print</span>(a.flatten(order=<span class="string">'F'</span>), end=<span class="string">', '</span>) <span class="comment"># [0, 3, 6, 1, 4, 7, 2, 5, 8, ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以行优先顺序展开数组</span></span><br><span class="line"><span class="built_in">print</span>(a.ravel(order=<span class="string">'C'</span>), end=<span class="string">', '</span>) <span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, ]</span></span><br></pre></td></tr></table></figure></div></li></ul><p><strong>对换数组维度（转置）</strong><br><code>numpy.transpose(&lt;array&gt;, &lt;axes&gt;)</code></p><ul><li><code>&lt;array&gt;</code>为需要对换数组维度的数组</li><li><code>&lt;axes&gt;</code>为对应维度的整数列表（通常对换所有维度）</li><li>类似于<code>numpy.ndarray.T</code></li></ul><p><strong>向后滚动特定数组坐标轴</strong><br><code>numpy.rollaxis(&lt;array&gt;, &lt;axis&gt;, &lt;start&gt;)</code></p><ul><li><code>&lt;array&gt;</code>为需要对坐标轴执行向后滚动操作的数组</li><li><code>&lt;axis&gt;</code>为需要向后滚动的轴</li><li><code>&lt;start&gt;</code>表示需要滚动至的特定位置，缺省为 0（第 0 个轴）</li><li>其他轴的相对位置不会改变</li></ul><p><strong>对换数组的两个坐标轴</strong><br><code>numpy.swapaxes(&lt;array&gt;, &lt;axis1&gt;, &lt;axis2&gt;)</code></p><ul><li><code>&lt;array&gt;</code>为需要执行对换坐标轴操作的数组</li><li><code>&lt;axis1&gt;</code>、<code>&lt;axis2&gt;</code>为对应两个轴的整数序号</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">8</span>).reshape(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">b = np.rollaxis(a, <span class="number">2</span>, <span class="number">0</span>) <span class="comment"># 轴2（宽度）滚动至轴0（深度）的位置</span></span><br><span class="line">c = np.swapaxes(a, <span class="number">2</span>, <span class="number">0</span>) <span class="comment"># 轴2（宽度）与轴0（深度）互换位置</span></span><br></pre></td></tr></table></figure></div><p><strong>在指定位置插入新轴以扩展数组</strong><br><code>numpy.expand_dims(&lt;array&gt;, &lt;axis&gt;)</code></p><ul><li><code>&lt;array&gt;</code>为执行数组</li><li><code>&lt;axis&gt;</code>为新轴所插入位置</li></ul><p><strong>在指定数组中删除值为1的维度</strong><br><code>numpy.squeeze(&lt;array&gt;, &lt;axis&gt;)</code></p><ul><li><code>&lt;array&gt;</code>为执行数组</li><li><code>&lt;axis&gt;</code>用于指定需要删除的维度（单维度），取值为<code>None</code>、<code>int</code>或<code>tuple of ints</code>，取值为空时删除所有值为 1 的维度（单维度）</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(<span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>, dtype=<span class="built_in">int</span>)</span><br><span class="line">y = np.array([[<span class="number">1</span>], [<span class="number">3</span>], [<span class="number">5</span>]])</span><br><span class="line"></span><br><span class="line">z = np.expand_dims(y, axis=<span class="number">1</span>) <span class="comment"># 在位置1插入新轴</span></span><br><span class="line"><span class="built_in">print</span>(z.shape) <span class="comment"># (3, 1, 1)</span></span><br><span class="line"></span><br><span class="line">z = np.squeeze(z，axis=(<span class="number">2</span>,))</span><br><span class="line"><span class="built_in">print</span>(z.shape) <span class="comment"># (3, 1)</span></span><br></pre></td></tr></table></figure></div><p><strong>沿指定轴连接相同形状的两个或多个数组</strong><br><code>numpy.concatenate(&lt;arrays&gt;, &lt;axis&gt;)</code></p><ul><li><code>&lt;arrays&gt;</code>为同类型同形状的数组</li><li><code>&lt;axis&gt;</code>指定连接数组的轴（缺省为 0，上下连接），若值为 1 则左右连接</li></ul><p><strong>沿新轴合并一系列数组</strong><br><code>numpy.stack(&lt;arrays&gt;, &lt;axis&gt;)</code></p><ul><li><code>&lt;arrays&gt;</code>为同类型同形状的数组</li><li><code>&lt;axis&gt;</code>指定数组序列的堆叠方向<table><thead><tr><th>axis值</th><th>说明</th></tr></thead><tbody><tr><td>axis=0</td><td>在最外层括号执行堆叠</td></tr><tr><td>axis=1</td><td>在次外层括号执行堆叠</td></tr><tr><td>axis=2</td><td>(三维数组中)在最内层括号内执行堆叠</td></tr></tbody></table></li><li>堆叠后的数组比原数组多一个维度</li></ul><p><strong>通过水平堆叠生成数组</strong><br><code>numpy.hstack(&lt;arrays&gt;)</code></p><ul><li><code>&lt;arrays&gt;</code>为同类型同形状的数组</li><li>相当于<code>numpy.concatenate()</code>方法中<code>&lt;axis&gt;</code>值为 1</li></ul><p><strong>通过垂直堆叠生成数组</strong><br><code>numpy.vstack(&lt;arrays&gt;)</code></p><ul><li><code>&lt;arrays&gt;</code>为同类型同形状的数组</li><li>相当于<code>numpy.concatenate()</code>方法中<code>&lt;axis&gt;</code>值为 0</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line">b = np.array([[<span class="number">4</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 沿轴1连接数组a与数组b</span></span><br><span class="line"><span class="built_in">print</span>(np.concatenate((a, b), axis=<span class="number">1</span>), end=<span class="string">'\n\n'</span>)</span><br><span class="line"><span class="built_in">print</span>(np.hstack((a, b)), end=<span class="string">'\n\n'</span>)</span><br><span class="line"><span class="comment"># [[1, 2, 4, 3], [3, 4, 2, 1]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.concatenate((a, b), axis=<span class="number">0</span>), end=<span class="string">'\n\n'</span>)</span><br><span class="line"><span class="built_in">print</span>(np.vstack((a, b)), end=<span class="string">'\n\n'</span>)</span><br><span class="line"><span class="comment"># [[1, 2], [3, 4], [4, 3], [2, 1]]</span></span><br><span class="line"></span><br><span class="line">c = np.stack((a, b), axis=<span class="number">0</span>) <span class="comment"># [[[1, 2], [3, 4]], [[4, 3], [2, 1]]]</span></span><br><span class="line"><span class="built_in">print</span>(np.stack((a, b), axis=<span class="number">1</span>)) <span class="comment"># [[[1, 2], [4, 3]], [[3, 4], [2, 1]]]</span></span><br><span class="line"><span class="built_in">print</span>(np.stack(c, axis=<span class="number">2</span>)) <span class="comment"># [[[1, 4], [2, 3]], [[3, 2], [4, 1]]]</span></span><br></pre></td></tr></table></figure></div><p><strong>沿特定轴分割数组</strong><br><code>numpy.split(&lt;array&gt;, &lt;indices_or_sections&gt;, &lt;axis&gt;)</code></p><ul><li><code>&lt;arrays&gt;</code>为被分割的数组</li><li><code>&lt;indices_or_sections&gt;</code>若为整数则将数组均分为该数等份，若为数组则决定沿轴分割位置</li><li><code>&lt;axis&gt;</code>决定数组沿着何方向分割，缺省为 0（横向分割），为 1 时纵向分割</li></ul><p><strong>纵向分割数组</strong><br><code>numpy.hsplit(&lt;array&gt;, &lt;indices_or_sections&gt;)</code></p><ul><li><code>&lt;arrays&gt;</code>为被分割的数组</li><li><code>&lt;indices_or_sections&gt;</code>若为整数则将数组均分为该数等份，若为数组则决定沿轴分割位置</li><li>相当于<code>numpy.split()</code>方法中<code>&lt;axis&gt;</code>值为 1</li></ul><p><strong>横向分割数组</strong><br><code>numpy.vsplit(&lt;array&gt;, &lt;indices_or_sections&gt;)</code></p><ul><li><code>&lt;arrays&gt;</code>为被分割的数组</li><li><code>&lt;indices_or_sections&gt;</code>若为整数则将数组均分为该数等份，若为数组则决定沿轴分割位置</li><li>相当于<code>numpy.split()</code>方法中<code>&lt;axis&gt;</code>值为 0<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">b = np.split(a, <span class="number">3</span>)</span><br><span class="line">c = np.split(a, [<span class="number">2</span>, <span class="number">4</span>])</span><br><span class="line"><span class="comment"># [0, 1], [2, 3], [4, 5]</span></span><br><span class="line"></span><br><span class="line">x = np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">y1 = np.split(x, <span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">y2 = np.hsplit(x, [<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="comment"># [[0], [3], [6]], [[1], [4], [7]], [[2], [5], [8]]</span></span><br></pre></td></tr></table></figure></div></li></ul><p><strong>返回指定大小的新数组</strong><br><code>numpy.resize(&lt;array&gt;, &lt;shape&gt;)</code></p><ul><li><code>&lt;arrays&gt;</code>为需要修改大小的数组</li><li><code>&lt;shape&gt;</code>为数组返回的新形状</li></ul><p><strong>分配整个数组并在数组的末尾追加值（扩展数组）</strong><br><code>numpy.append(&lt;array&gt;, &lt;values&gt;, &lt;axis&gt;)</code></p><ul><li><code>&lt;arrays&gt;</code>为需要扩展的数组</li><li><code>&lt;values&gt;</code>为需要向数组扩展的数组内容（与原数组形状相同）</li><li><code>&lt;axis&gt;</code>指定数组扩展方向，默认为<code>None</code>并返回一维数组。若定义值为 0 则纵向扩展（列数需一致），定义值为 1 则横向扩展（行数需一致）</li></ul><p><strong>在指定索引前沿指定轴在数组中插入值</strong><br><code>numpy.insert(&lt;array&gt;, &lt;index&gt;, &lt;values&gt;, &lt;axis&gt;)</code></p><ul><li><code>&lt;arrays&gt;</code>为需要插入值的数组</li><li><code>&lt;index&gt;</code>为插入位置的索引</li><li><code>&lt;values&gt;</code>为需要插入的值</li><li><code>&lt;axis&gt;</code>为插入位置所沿的轴，默认展开原数组。若定义值为 0 则横向插入，定义值为 1 则纵向插入</li></ul><p><strong>在指定索引沿指定轴在数组中删除指定子数组</strong><br><code>numpy.delete(&lt;array&gt;, &lt;index&gt;, &lt;axis&gt;)</code></p><ul><li><code>&lt;arrays&gt;</code>为需要删除值的数组</li><li><code>&lt;index&gt;</code>为删除位置的索引</li><li><code>&lt;axis&gt;</code>为删除位置所沿的轴，默认展开原数组。若定义值为 0 则横向删除，定义值为 1 则纵向删除</li></ul><p><strong>删除数组中重复元素</strong><br><code>numpy.unique(&lt;array&gt;, &lt;return_index&gt;, &lt;return_inverse&gt;, &lt;return_counts&gt;)</code></p><ul><li><code>&lt;arrays&gt;</code>为需要去重的数组</li><li><code>&lt;return_index&gt;</code>若为<code>True</code>，则返回去重后数组内元素在原数组中的索引位置（列表形式）</li><li><code>&lt;return_inverse&gt;</code>若为<code>True</code>，则返回原数组内元素在去重后数组中的索引位置（列表形式）</li><li><code>&lt;return_counts&gt;</code>若为<code>True</code>，则返回原数组内各元素出现次数<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line">b1 = np.resize(a, (<span class="number">3</span>, <span class="number">2</span>))  <span class="comment"># [[1, 2], [3, 4], [5, 6]]</span></span><br><span class="line">b2 = np.resize(a, (<span class="number">3</span>, <span class="number">3</span>))  <span class="comment"># [[1, 2, 3], [4, 5, 6], [1, 2, 3]]</span></span><br><span class="line"></span><br><span class="line">c1 = np.insert(a, <span class="number">3</span>, [<span class="number">3</span>, <span class="number">4</span>])  <span class="comment"># [1, 2, 3, 3, 4, 4, 5, 6]</span></span><br><span class="line">c2 = np.insert(a, <span class="number">2</span>, [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], axis=<span class="number">0</span>)  <span class="comment"># [[1, 2, 3], [4, 5, 6], [7, 8, 9]]</span></span><br><span class="line">c3 = np.insert(a, [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">9</span>], axis=<span class="number">1</span>)  <span class="comment"># [[1, 9, 2, 9, 3], [4, 9, 5, 9, 6]]</span></span><br><span class="line"></span><br><span class="line">d1 = np.delete(c3, [<span class="number">1</span>, <span class="number">3</span>], axis=<span class="number">1</span>) <span class="comment">#[[1, 2, 3], [4, 5, 6]]</span></span><br><span class="line">d2 = np.delete(a, np.s_[::<span class="number">2</span>]) <span class="comment">#[2, 4, 6]</span></span><br><span class="line"></span><br><span class="line">e, indices = np.unique(c1, return_index=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(e)  <span class="comment"># [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="built_in">print</span>(indices)  <span class="comment"># [0, 1, 2, 4, 5, 6, 7]</span></span><br></pre></td></tr></table></figure></div></li></ul><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p>对数组中整数元素的二进制形式执行位运算</p><table><thead><tr><th>运算方法</th><th>说明</th></tr></thead><tbody><tr><td><code>numpy.bitwise_and(&lt;numbers&gt;)</code></td><td>位与运算</td></tr><tr><td><code>numpy.bitwise_or(&lt;numbers&gt;)</code></td><td>位或运算</td></tr><tr><td><code>numpy.invert(&lt;number&gt;)</code></td><td>取反运算</td></tr></tbody></table><p><strong>将数组中元素的二进制形式左移指定位置，右侧补上相应数量的 0</strong><br><code>numpy.left_shift(&lt;number&gt;，&lt;movement&gt;)</code></p><ul><li><code>&lt;number&gt;</code>为数组中元素</li><li><code>&lt;movement&gt;</code>为数组左移位数</li></ul><p><strong>将数组中元素的二进制形式右移指定位置，左侧补上相应数量的 0</strong><br><code>numpy.right_shift(&lt;number&gt;，&lt;movement&gt;)</code></p><ul><li><code>&lt;number&gt;</code>为数组中元素</li><li><code>&lt;movement&gt;</code>为数组右移位数</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.bitwise_and(<span class="number">21</span>, <span class="number">25</span>))</span><br><span class="line"><span class="comment"># 0b10101 + 0b11001 == 0b10001 (17)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.bitwise_or(<span class="number">21</span>, <span class="number">25</span>))</span><br><span class="line"><span class="comment"># 0b10101 + 0b11001 == 0b11101 (29)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.invert(<span class="number">7</span>))</span><br><span class="line"><span class="comment"># 原码转二进制 0b00000111</span></span><br><span class="line"><span class="comment"># 按位取反 0b11111000</span></span><br><span class="line"><span class="comment"># 首位为1表示负数，将除符号位外的其他位取反 0b10000111</span></span><br><span class="line"><span class="comment"># (末位加1)取补码 0b10001000</span></span><br><span class="line"><span class="comment"># 转回十进制 -8</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.left_shift(<span class="number">7</span>, <span class="number">3</span>))</span><br><span class="line"><span class="comment"># 0b00000111 --&gt; 0b00111000 (56)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.right_shift(<span class="number">56</span>, <span class="number">3</span>))</span><br><span class="line"><span class="comment"># 0b00111000 --&gt; 0b00000111 (7)</span></span><br></pre></td></tr></table></figure></div><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>numpy.char.add(&lt;strings&gt;)</code></td><td>连接两个字符串元素</td></tr><tr><td><code>numpy.char.multiply(&lt;string&gt;)</code></td><td>复制某个指定字符串元素并连接（多重连接）</td></tr><tr><td><code>numpy.char.center(&lt;strings&gt;, &lt;length&gt;, &lt;fillchar&gt;)</code></td><td>将字符串居中，并指定一个字符在左右两侧填充</td></tr><tr><td><code>numpy.char.capitalize(&lt;strings&gt;)</code></td><td>将字符串的首字母转换为大写</td></tr><tr><td><code>numpy.char.title(&lt;strings&gt;)</code></td><td>将字符串的每个单词的首字母均转换为大写</td></tr><tr><td><code>numpy.char.upper(&lt;strings&gt;)</code></td><td>将字符串的每个元素转换为大写</td></tr><tr><td><code>numpy.char.lower(&lt;strings&gt;)</code></td><td>将字符串的每个元素转换为小写</td></tr><tr><td><code>numpy.char.split([&lt;strings&gt;], [&lt;seperates&gt;])</code></td><td>指定分隔符（默认空格）分割字符串，并返回数组</td></tr><tr><td><code>numpy.char.splitlines(&lt;strings&gt;)</code></td><td>将换行符作为分隔符以分割字符串，并返回数组</td></tr><tr><td><code>numpy.char.strip([&lt;strings&gt;], &lt;char_to_delete&gt;)</code></td><td>移除开头处与结尾处的某个指定字符</td></tr><tr><td><code>numpy.char.join([&lt;fill_chars&gt;], [&lt;strings&gt;])</code></td><td>指定分隔符填充字符串中字符间的间隔</td></tr><tr><td><code>numpy.char.replace(&lt;strings&gt;, &lt;string_to_replace&gt;, &lt;replacement&gt;)</code></td><td>使用一个新字符串替换一个指定的原字符串中的所有子字符串</td></tr><tr><td><code>numpy.char.encode(&lt;strings&gt;, &lt;encoder&gt;)</code></td><td>对元素进行编码（默认编码为 <code>uft-8</code> ）</td></tr><tr><td><code>numpy.char.encode(&lt;strings&gt;, &lt;decoder&gt;)</code></td><td>对元素进行解码（默认解码为 <code>uft-8</code> ）</td></tr></tbody></table><h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>numpy.add()</code></td><td>加法</td></tr><tr><td><code>numpy.subtract()</code></td><td>减法</td></tr><tr><td><code>numpy.multiply()</code></td><td>乘法</td></tr><tr><td><code>numpy.divide()</code></td><td>除法</td></tr><tr><td><code>numpy.reciprocal()</code></td><td>取倒数</td></tr><tr><td><code>numpy.power()</code></td><td>取幂</td></tr><tr><td><code>numpy.mod()</code></td><td>取余</td></tr><tr><td><code>numpy.dot()</code></td><td>数组点积</td></tr><tr><td><code>numpy.vdot()</code></td><td>向量点积</td></tr><tr><td><code>numpy.inner()</code></td><td>数组内积</td></tr><tr><td><code>numpy.matmul()</code></td><td>矩阵积</td></tr><tr><td><code>numpy.sin()</code></td><td>正弦函数</td></tr><tr><td><code>numpy.cos()</code></td><td>余弦函数</td></tr><tr><td><code>numpy.tan()</code></td><td>正切函数</td></tr><tr><td><code>numpy.arctan()</code></td><td>反正弦函数</td></tr><tr><td><code>numpy.arccos()</code></td><td>反余弦函数</td></tr><tr><td><code>numpy.arctan()</code></td><td>反正切函数</td></tr><tr><td><code>numpy.degrees()</code></td><td>弧度转角度</td></tr><tr><td><code>numpy.around(&lt;number&gt;, &lt;decimals&gt;)</code></td><td>四舍五入</td></tr><tr><td><code>numpy.floor()</code></td><td>向下取整</td></tr><tr><td><code>numpy.ceil()</code></td><td>向上取整</td></tr></tbody></table><ul><li><code>&lt;decimals&gt;</code>指定舍入的小数位数，缺省为 0 ，若为负数则将整数四舍五入至小数点左侧</li><li>执行运算前各运算元素须具有相同形状或符合数组广播规则</li></ul><p><strong>两个数组的点积</strong><br><code>numpy.dot(&lt;ndarrays&gt;, &lt;out&gt;)</code></p><ul><li><code>&lt;ndarrays&gt;</code>若为一维数组，结果为两数组的内积；若为二维数组，结果为两数组的矩阵乘积；若为多维数组，结果为数组最后一维上所有元素与另一数组倒数第二维上所有元素的乘积之和</li><li><code>&lt;out&gt;</code>存储计算结果</li></ul><p><strong>两个向量的点积</strong><br><code>numpy.vdot(&lt;ndarrays&gt;)</code></p><ul><li><code>&lt;ndarrays&gt;</code>中第一个参数若为复数，则其共轭复数会被用于计算；若为多维数组，则会被展开</li></ul><p><strong>一维数组的向量内积</strong><br><code>numpy.inner(&lt;ndarrays&gt;)</code></p><ul><li><code>&lt;ndarrays&gt;</code>若维度大于 1 ，则返回沿最后一个轴的矩阵乘积</li></ul><p><strong>两个数组的矩阵乘积</strong><br><code>numpy.matmul(&lt;ndarrays&gt;)</code></p><ul><li><code>&lt;ndarrays&gt;</code>若为二维数组，则结果为矩阵乘法；若任意数组的维数大于 2 ，则将其视作存在于最后两个索引的矩阵的栈，并进行相应广播；若任意数组为一维数组，则将其维度加 1 变为矩阵，乘法结束后去除</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line">y = np.array([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.dot(x, y))  <span class="comment"># [[19, 22], [43, 50]](矩阵乘积)</span></span><br><span class="line"><span class="built_in">print</span>(np.vdot(x, y))  <span class="comment"># 70（矩阵内积）</span></span><br><span class="line"><span class="built_in">print</span>(np.inner(x, y))  <span class="comment"># [[17, 23], [39, 53]]</span></span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">1</span>+<span class="number">2j</span>, <span class="number">3</span>+<span class="number">4j</span>])</span><br><span class="line">b = np.array([<span class="number">5</span>+<span class="number">6j</span>, <span class="number">7</span>+<span class="number">8j</span>])</span><br><span class="line"><span class="built_in">print</span>(np.vdot(a, b))  <span class="comment"># (70-8j)</span></span><br><span class="line"><span class="built_in">print</span>(np.vdot(b, a))  <span class="comment"># (70+8j)</span></span><br></pre></td></tr></table></figure></div><p><strong>计算输入矩阵的行列式的值</strong><br><code>numpy.linalg.det(&lt;ndarrays&gt;)</code></p><p><strong>计算矩阵形式的线性方程的解</strong><br><code>numpy.linalg.solve(&lt;ndarray_formula&gt;, &lt;ndarray_result&gt;)</code></p><ul><li><code>&lt;ndarray_formula&gt;</code>为线性方程未知数部分的参数</li><li><code>&lt;ndarray_result&gt;</code>为线性方程组结果</li></ul><p><strong>计算矩阵的逆矩阵</strong><br><code>numpy.linalg.inv(&lt;ndarray&gt;)</code></p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">4</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line">b = np.array([<span class="number">2</span>, <span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(np.linalg.det(a))  <span class="comment"># -2.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#计算线性方程组 4x+3y=2, 2x+y=4 的结果</span></span><br><span class="line"><span class="built_in">print</span>(np.linalg.solve(a, b))  <span class="comment">#[5, -6](x==5, y==-6)</span></span><br><span class="line"></span><br><span class="line">c = np.linalg.inv(a)  <span class="comment"># [[-0.5, 1.5], [ 1., -2.]]</span></span><br><span class="line"><span class="built_in">print</span>(np.dot(a, c))  <span class="comment"># [[1., 0.], [0., 1.]]</span></span><br></pre></td></tr></table></figure></div><h1 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h1><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>numpy.amin(&lt;array&gt;, &lt;axis&gt;)</code></td><td>数组元素沿指定轴的最小值</td></tr><tr><td><code>numpy.amax(&lt;array&gt;, &lt;axis&gt;)</code></td><td>数组元素沿指定轴的最大值</td></tr><tr><td><code>numpy.ptp(&lt;array&gt;, &lt;axis&gt;)</code></td><td>数组沿指定轴的极差</td></tr><tr><td><code>numpy.percentile(&lt;array&gt;, &lt;percentage&gt;, &lt;axis&gt;)</code></td><td>数组指定百分位沿指定轴的分位数</td></tr><tr><td><code>numpy.median(&lt;array&gt;, &lt;axis&gt;)</code></td><td>数组沿指定轴的中位数</td></tr><tr><td><code>numpy.mean(&lt;array&gt;, &lt;axis&gt;)</code></td><td>数组沿指定轴的平均数</td></tr><tr><td><code>numpy.average(&lt;array&gt;, &lt;weight&gt;, &lt;axis&gt;)</code></td><td>根据另一数组中所给权重计算数组中元素的加权平均值</td></tr><tr><td><code>numpy.std(&lt;array&gt;, &lt;axis&gt;)</code></td><td>数组沿指定轴的标准差</td></tr><tr><td><code>numpy.var(&lt;array&gt;, &lt;axis&gt;)</code></td><td>数组沿指定轴的方差</td></tr></tbody></table><ul><li><code>numpy.average()</code>方法在不给定<code>&lt;weight&gt;</code>时相当于<code>numpy.mean()</code>方法，</li><li>在未指定<code>&lt;axis&gt;</code>时上述方法将展开数组</li></ul><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p><strong>返回数组排序后的副本</strong><br><code>numpy.sort(&lt;array&gt;, &lt;axis&gt;, &lt;sort_approach&gt;, &lt;order&gt;)</code></p><ul><li><code>&lt;array&gt;</code>为需要排序的数组</li><li><code>&lt;axis&gt;</code>指定排序所沿的轴</li><li><code>&lt;kind&gt;</code>指定排序方法<table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>'quicksort'</code></td><td>快速排序</td></tr><tr><td><code>'mergesort'</code></td><td>归并排序</td></tr><tr><td><code>'heapsort'</code></td><td>堆排序</td></tr></tbody></table></li><li><code>&lt;order&gt;</code>指定所排序的字段</li></ul><p><strong>返回数组内从小到大的数组值的索引值</strong><br><code>numpy.argsort(&lt;array&gt;, &lt;axis&gt;)</code></p><p><strong>同时对多个序列排序并返回排序结果中各元素在原数组中对应的索引值</strong><br><code>numpy.lexsort(&lt;arrays&gt;)</code></p><p><strong>沿列排序</strong><br><code>numpy.msort(&lt;array&gt;)</code></p><ul><li>相当于<code>np.sort()</code>方法中<code>&lt;axis&gt;</code>值为 0</li></ul><p><strong>以先实部后虚部的顺序对复数排序</strong><br><code>numpy.sort_complex(&lt;array&gt;)</code></p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">data = np.dtype([(<span class="string">'name'</span>, <span class="string">'S10'</span>), (<span class="string">'age'</span>, <span class="built_in">int</span>)])</span><br><span class="line">stu = np.array([(<span class="string">'Dylan'</span>, <span class="number">17</span>), (<span class="string">'Alice'</span>, <span class="number">16</span>), (<span class="string">'Frank'</span>, <span class="number">18</span>)], dtype=data)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.sort(stu, order=<span class="string">'age'</span>))  <span class="comment">#按age排序</span></span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>])</span><br><span class="line">y = np.argsort(x)</span><br><span class="line"><span class="built_in">print</span>(x[y])  <span class="comment"># 重构数组</span></span><br><span class="line"></span><br><span class="line">name = [[<span class="string">'Dylan'</span>], [<span class="string">'Alice'</span>], [<span class="string">'Frank'</span>]]</span><br><span class="line">cls = [[<span class="string">'A'</span>], [<span class="string">'B'</span>], [<span class="string">'A'</span>]]</span><br><span class="line"><span class="built_in">print</span>(np.lexsort((cls, name)), end=<span class="string">'\n\n'</span>) <span class="comment">#排序索引结果</span></span><br><span class="line"><span class="built_in">print</span>([name[i] + <span class="string">','</span> + cls[i] <span class="keyword">for</span> i <span class="keyword">in</span> cls]) <span class="comment">#排序结果</span></span><br></pre></td></tr></table></figure></div><p><strong>挑选指定数组中最小的几个元素置于数组最前端，并与其他元素分为两堆</strong><br><code>numpy.partition(&lt;array&gt;, &lt;kth&gt;, &lt;axis&gt;)</code></p><ul><li>新数组中前<code>&lt;count&gt;</code>个元素为原数组中最小的<code>&lt;count&gt;</code>个元素</li><li>仅将最小的<code>&lt;count&gt;</code>个元素置于数组最前端，不需要完整排序（类似快速排序过程）</li><li>返回分区后的新数组</li></ul><p><strong>挑选指定数组中最小的几个元素置于数组最前端，并与其他元素分为两堆</strong><br><code>numpy.argpartition(&lt;array&gt;, &lt;kth&gt;, &lt;axis&gt;)</code></p><ul><li>与<code>numpy.partition()</code>的主要功能相同</li><li>返回分区后的新数组内元素在原数组中的索引号</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([<span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>, -<span class="number">4</span>, -<span class="number">3</span>, -<span class="number">6</span>, -<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(np.partition(arr, kth=<span class="number">4</span>))  <span class="comment"># [-6, -4, -3, -1, 1, 4, 7, 5, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回数组中最小的3个数字</span></span><br><span class="line"><span class="built_in">print</span>(np.partition(arr, kth=<span class="number">3</span>)[:<span class="number">3</span>], end=<span class="string">'\n\n'</span>)</span><br><span class="line"><span class="built_in">print</span>(arr[np.argpartition(arr, kth=<span class="number">3</span>)[:<span class="number">3</span>]])</span><br><span class="line"><span class="comment"># [-6, -4, -3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回数组中最大的5个数字</span></span><br><span class="line"><span class="built_in">print</span>(np.partition(arr, kth=-<span class="number">5</span>)[-<span class="number">5</span>:], end=<span class="string">'\n\n'</span>)</span><br><span class="line"><span class="built_in">print</span>(arr[np.argpartition(arr, kth=-<span class="number">5</span>)[-<span class="number">5</span>:]])</span><br><span class="line"><span class="comment"># [1, 4, 7, 5, 9]</span></span><br></pre></td></tr></table></figure></div><h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><p><strong>将数组保存到以 .npy 为扩展名的文件中</strong><br><code>numpy.save(&lt;fname&gt;, &lt;array&gt;, &lt;allow_pickle&gt;, &lt;fix_imports&gt;)</code></p><ul><li><code>&lt;fname&gt;</code>为需要保存的文件名</li><li><code>&lt;array&gt;</code>为需要保存的数组</li><li><code>&lt;allow_pickle&gt;</code>允许使用Python pickles保存对象数组，Python中的pickle用于在保存到磁盘文件或从磁盘文件读取之前，对对象进行序列化和反序列化，默认为<code>False</code></li><li><code>&lt;fix_imports&gt;</code>方便从Pyhton2中读取Python3中保存的数据，默认为<code>True</code></li></ul><p><strong>读取 .npy 文件</strong></p><p><code>numpy.load(&lt;fname&gt;, &lt;allow_pickle&gt;, &lt;fix_imports&gt;)</code></p><ul><li><code>&lt;fname&gt;</code>为需要保存的文件名</li><li><code>&lt;allow_pickle&gt;</code>允许使用Python pickles读取对象数组，默认为<code>False</code></li><li><code>&lt;fix_imports&gt;</code>方便从Python2中读取Python3中保存的数据，默认为<code>True</code></li></ul><p><strong>将多个数组保存到以 .npz 为扩展名的文件中</strong><br><code>numpy.savez(&lt;fname&gt;, *args, **kwds)</code></p><ul><li><code>&lt;fname&gt;</code>为需要保存的文件名</li><li><code>*args</code>为需要保存的数组，可以使用关键字参数为数组命名，否则数组会自动命名为 arr_0, arr_1, …</li><li><code>**kwds</code>为需要保存的数组使用的关键字名称</li></ul><p><strong>以简单的文本文件格式存储数据</strong><br><code>np.savetxt(&lt;fname&gt;, &lt;array&gt;, &lt;fmt&gt;, &lt;delimiter&gt;)</code></p><ul><li><code>&lt;fname&gt;</code>为需要保存的文件名</li><li><code>&lt;array&gt;</code>为需要保存的数组</li><li><code>&lt;fmt&gt;</code>指定存储数据类型，默认为’%.18e’</li><li><code>&lt;delimiter&gt;</code>指定元素之间的分隔符，默认为空格</li></ul><p><strong>读取 .txt 文件</strong><br><code>np.loadtxt(&lt;fname&gt;, &lt;dtype&gt;, &lt;delimiter&gt;)</code></p><ul><li><code>&lt;fname&gt;</code>为需要读取的文件名</li><li><code>&lt;dtype&gt;</code>指定读取所返回的数据类型，默认为<code>float</code></li><li><code>&lt;delimiter&gt;</code>指定读取的分隔符，默认无分隔符</li></ul><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><p>自 1.19.0 版本后Numpy官方已不推荐引用<code>numpy.matlib</code>方法，同时不推荐通过矩阵类表示矩阵或处理线性代数问题(见 <a class="link" href="https://docs.scipy.org/doc/numpy/user/numpy-for-matlab-users">https://docs.scipy.org/doc/numpy/user/numpy-for-matlab-users <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>) ，建议使用常规<code>Ndarray</code>类。</p>]]></content>
      
      
      <categories>
          
          <category> summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas库的主要使用方法</title>
      <link href="/2022/10/11/pandas/"/>
      <url>/2022/10/11/pandas/</url>
      
        <content type="html"><![CDATA[<p><code>import pandas as pd</code></p><h1 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h1><p>Series由index和列组成，类似于一维数组（或数据库中的id与数据实体）<br><code>pandas.Series(&lt;data&gt;, &lt;index&gt;, &lt;dtype&gt;, &lt;series_name&gt;, &lt;copy&gt;)</code></p><ul><li><code>&lt;data&gt;</code>为list、tuple、dict等ndarray类型</li><li><code>&lt;index&gt;</code>为数据索引标签，默认从 0 开始</li><li><code>&lt;dtype&gt;</code>为所存储数据类型（默认自动判断）</li><li><code>&lt;name&gt;</code>为Series名称</li><li><code>&lt;copy&gt;</code>为拷贝数据，缺省为<code>False</code></li><li>‘Series’首字母要大写<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">myvar = pd.Series(a)</span><br><span class="line"><span class="built_in">print</span>(myvar)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(myvar[<span class="number">2</span>])  <span class="comment"># 根据索引值读取数据</span></span><br><span class="line">myvar = pd.Series(a, index=[<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>])  <span class="comment"># 也可指定索引值</span></span><br></pre></td></tr></table></figure></div></li></ul><p>通过dict创建Series，字典的key会变为series的索引值</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">name = &#123;<span class="number">1</span>: <span class="string">&quot;Alice&quot;</span>, <span class="number">2</span>: <span class="string">&quot;Bob&quot;</span>, <span class="number">3</span>: <span class="string">&quot;Cindy&quot;</span>&#125;</span><br><span class="line">myvar = pd.Series(name)</span><br><span class="line"><span class="built_in">print</span>(myvar)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 若仅需dict中的部分数据，仅需指定所需数据的索引即可</span></span><br><span class="line">myvar = pd.Series(name, index=[<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置Series名称</span></span><br><span class="line">myvar = pd.Series(myvar, name=<span class="string">&#x27;Series_test&#x27;</span>)</span><br></pre></td></tr></table></figure></div><h1 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h1><ul><li>DataFrame为二维表格型数据结构（存在行索引与列索引），类似于二维数组</li><li>其含有一组有序的列，每列数据类型可不同</li><li>类似于由一组Series组成的dict</li></ul><p><code>pandas.DataFrame(&lt;data&gt;, &lt;index&gt;, &lt;columns&gt;, &lt;dtype&gt;, &lt;copy&gt;)</code></p><ul><li><code>&lt;data&gt;</code>为list、tuple、dict等ndarray类型</li><li><code>&lt;index&gt;</code>为数据索引标签（或行标签）</li><li><code>&lt;columns&gt;</code>为列标签，缺省为 RangeIndex(0, 1, 2, …, n)</li><li><code>&lt;dtype&gt;</code>为所存储数据类型（默认自动判断）</li><li><code>&lt;copy&gt;</code>为拷贝数据，缺省为<code>False</code><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = [[<span class="string">&#x27;Alice&#x27;</span>, <span class="number">10</span>], [<span class="string">&#x27;Bob&#x27;</span>, <span class="number">12</span>], [<span class="string">&#x27;Cindy&#x27;</span>, <span class="number">13</span>]]</span><br><span class="line">df = pd.DataFrame(data, columns=[<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>]) <span class="comment">#或index=[&#x27;stu1&#x27;, &#x27;stu2&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure></div></li></ul><p>使用dict配合ndarrays创建DataFrame</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;<span class="string">&#x27;Name&#x27;</span>:[<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Cindy&#x27;</span>], <span class="string">&#x27;Age&#x27;</span>:[<span class="number">10</span>, <span class="number">12</span>, <span class="number">13</span>]&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure></div><ul><li>ndarrays的长度需相同</li><li>若传递了<code>&lt;index&gt;</code>，则<code>&lt;index&gt;</code>的长度应等于ndarray的长度</li><li>若未传递<code>&lt;index&gt;</code>，则缺省下索引为<code>range(n)</code>，其中 n 为ndarray长度</li></ul><p>使用dict(key&#x2F;value)创建DataFrame，其中dict的key为列名</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = [&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;, &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">20</span>&#125;]</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure></div><p>可使用<code>loc</code>属性返回指定行的数据，缺省下第一行索引为 0<br>比如第一行为<code>df.loc[0]</code>或<code>df.loc[&#39;stu1&#39;]</code><br>第一行及第二行为<code>df.loc[[0, 1]]</code>或<code>df.loc[[&#39;stu1&#39;, &#39;stu2&#39;]]</code><br>返回结果为一个Series数据</p><h1 id="csv"><a href="#csv" class="headerlink" title=".csv"></a>.csv</h1><p>通过<code>read_csv()</code>将.csv文件转储为DataFrame数据</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df = pd.read_csv(<span class="string">&#x27;example.csv&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(df.to_string()) <span class="comment">#to_string()返回DataFrame数据，否则仅输出前五行与后五行</span></span><br></pre></td></tr></table></figure></div><p>或通过<code>to_csv()</code>将DataFrame数据转储为.csv文件</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#三个字段name, age, gender</span></span><br><span class="line">name = [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Cindy&#x27;</span>]</span><br><span class="line">age = [<span class="number">10</span>, <span class="number">12</span>, <span class="number">13</span>]</span><br><span class="line">gender = [<span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;F&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#字典</span></span><br><span class="line"><span class="built_in">dict</span> = &#123;<span class="string">&#x27;name&#x27;</span>: name, <span class="string">&#x27;age&#x27;</span>: age, <span class="string">&#x27;gender&#x27;</span>: gender&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(<span class="built_in">dict</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#保存</span></span><br><span class="line">df.to_csv(<span class="string">&#x27;stu.csv&#x27;</span>)</span><br></pre></td></tr></table></figure></div><ul><li>通过<code>head(n)</code>方法读取前n行（缺省前五行）</li><li>通过<code>tail(n)</code>方法读取后n行（缺省后五行）</li><li>通过<code>info()</code>方法返回.csv文件基本信息（如行数、列数、各列数据类型等）<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(df.head()) <span class="comment">#前五行</span></span><br><span class="line"><span class="built_in">print</span>(df.tail(<span class="number">7</span>)) <span class="comment">#后七行</span></span><br><span class="line"><span class="built_in">print</span>(df.info()) <span class="comment">#.csv信息</span></span><br></pre></td></tr></table></figure></div></li></ul><h1 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h1><h2 id="统计计算"><a href="#统计计算" class="headerlink" title="统计计算"></a>统计计算</h2><ul><li>使用<code>mean()</code>方法计算列的均值</li><li>使用<code>median()</code>方法计算列的中位数</li><li>使用<code>mode()</code>方法计算列的众数</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df = pd.read_csv(<span class="string">&#x27;stu.csv&#x27;</span>)</span><br><span class="line">avg = df[<span class="string">&#x27;grade&#x27;</span>].mean() <span class="comment">#计算grade列的平均数</span></span><br><span class="line">mid = df[<span class="string">&#x27;grade&#x27;</span>].median() <span class="comment">#计算grade列的中位数</span></span><br><span class="line">mod = df[<span class="string">&#x27;grade&#x27;</span>].mode() <span class="comment">#计算grade列的众数</span></span><br></pre></td></tr></table></figure></div><h2 id="去除空值"><a href="#去除空值" class="headerlink" title="去除空值"></a>去除空值</h2><p><code>DataFrame.dropna(&lt;axis&gt;, &lt;how&gt;, &lt;thresh&gt;, &lt;subset&gt;, &lt;inplace&gt;)</code></p><ul><li><p><code>&lt;axis&gt;</code>默认为 0，即逢空值剔除整行，若设置为 1 则表示逢空值剔除整列</p></li><li><p><code>&lt;how&gt;</code>默认为’any’，即一行（或一列）中任何数据为空则剔除整行（或整列），若设置为’all’则仅当一行（或一列）中任何数据均为空时才剔除整行（或整列）</p></li><li><p><code>&lt;thresh&gt;</code>设置保留整行（或整列）所需的非空值的数量阈值</p></li><li><p><code>&lt;subset&gt;</code>设置需要检查的列</p></li><li><p><code>&lt;inplace&gt;</code>默认为<code>False</code>，即返回一个新的DataFrame，不会修改原数据。若设置为<code>True</code>，则将计算得到的值覆盖原数据并返回<code>None</code></p></li><li><p>通过<code>isnull()</code>方法判断列（或行）中各单元格是否为空</p></li><li><p>通过<code>na_values</code>指定空数据类型</p></li><li><p>通过<code>fillna</code>指定特定值替换空字段</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">missing_values = [<span class="string">&#x27;n/a&#x27;</span>, <span class="string">&#x27;na&#x27;</span>, <span class="string">&#x27;--&#x27;</span>] <span class="comment">#指定空数据范例</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;stu.csv&#x27;</span>, na_values = missing_values)</span><br><span class="line"><span class="built_in">print</span>(df[<span class="string">&#x27;city&#x27;</span>].isnull())</span><br><span class="line"></span><br><span class="line">new_df = df.dropna(subset=[<span class="string">&#x27;city&#x27;</span>]) <span class="comment">#剔除city列中字段值为空的行</span></span><br><span class="line"><span class="built_in">print</span>(new_df.to_string()) <span class="comment">#输出新DataFrame</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#指定city列中使用&#x27;null_city&#x27;替换空字段</span></span><br><span class="line">df[<span class="string">&#x27;city&#x27;</span>].fillna(<span class="string">&#x27;null_city&#x27;</span>, inplace=<span class="literal">True</span>) </span><br><span class="line"><span class="built_in">print</span>(df.to_string())</span><br></pre></td></tr></table></figure></div></li></ul><h2 id="去除格式错误数据"><a href="#去除格式错误数据" class="headerlink" title="去除格式错误数据"></a>去除格式错误数据</h2><p>将列中单元格统一转换为相同格式的数据</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#第三个日期格式错误</span></span><br><span class="line">data = &#123;</span><br><span class="line"><span class="string">&#x27;Date&#x27;</span>: [<span class="string">&#x27;2022/12/01&#x27;</span>, <span class="string">&#x27;2022/12/02&#x27;</span>, <span class="string">&#x27;20221203&#x27;</span>],</span><br><span class="line"><span class="string">&#x27;Count&#x27;</span>: [<span class="number">50</span>, <span class="number">40</span>, <span class="number">30</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(data, index=[<span class="string">&#x27;day1&#x27;</span>, <span class="string">&#x27;day2&#x27;</span>, <span class="string">&#x27;day3&#x27;</span>])</span><br><span class="line">df[<span class="string">&#x27;Date&#x27;</span>] = pd.to_datetime(df[<span class="string">&#x27;Date&#x27;</span>]) <span class="comment">#将Date列统一转换为Datetime格式</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df.to_string())</span><br></pre></td></tr></table></figure></div><h2 id="去除内容错误数据"><a href="#去除内容错误数据" class="headerlink" title="去除内容错误数据"></a>去除内容错误数据</h2><p>对错误数据进行替换或移除</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">person = &#123;</span><br><span class="line"><span class="string">&#x27;name&#x27;</span>: [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Cindy&#x27;</span>],</span><br><span class="line"><span class="string">&#x27;age&#x27;</span>: [<span class="number">10</span>, <span class="number">12</span>, <span class="number">1333</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(person)</span><br><span class="line">df.loc[<span class="number">2</span>, <span class="string">&#x27;age&#x27;</span>] = <span class="number">13</span> <span class="comment">#直接修改数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#若年龄大于100则默认修改为20</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> df.index:</span><br><span class="line"><span class="keyword">if</span> df.loc[x, <span class="string">&#x27;age&#x27;</span>] &gt; <span class="number">100</span>:</span><br><span class="line">df.loc[x, <span class="string">&#x27;age&#x27;</span>] = <span class="number">20</span></span><br><span class="line"><span class="comment">#或df.drop(x, inplace=True)将年龄大于100的行删除</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df.to_string())</span><br></pre></td></tr></table></figure></div><h2 id="去除重复数据"><a href="#去除重复数据" class="headerlink" title="去除重复数据"></a>去除重复数据</h2><ul><li>通过<code>duplicated()</code>检测重复数据</li><li>通过<code>drop_duplicates()</code>删除重复数据<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">person = &#123;</span><br><span class="line"><span class="string">&#x27;name&#x27;</span>: [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Cindy&#x27;</span>],</span><br><span class="line"><span class="string">&#x27;age&#x27;</span>: [<span class="number">10</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">1333</span>]</span><br><span class="line">&#125;</span><br><span class="line">df = pd.DataFrame(person)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df.duplicated()) <span class="comment">#重复数据返回True</span></span><br><span class="line"></span><br><span class="line">df.drop_duplicates(inplace=<span class="literal">True</span>) <span class="comment">#删除重复行</span></span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure></div></li></ul>]]></content>
      
      
      <categories>
          
          <category> summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Encantado de conocerte en el mundo</title>
      <link href="/2022/09/18/my-first-blog/"/>
      <url>/2022/09/18/my-first-blog/</url>
      
        <content type="html"><![CDATA[<h2 id="成功建站！"><a href="#成功建站！" class="headerlink" title="成功建站！"></a>成功建站！</h2><p>极简风格的小博客，以后将自己的学习过程以及其中的小心得和小思考码在这里ww</p><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello world!&#x27;</span>)</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
