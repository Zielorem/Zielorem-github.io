<!DOCTYPE html>
<html lang="en" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keywords" content="" />
  <meta name="author" content="Zielorem" />
  <meta name="description" content="" />
  
  
  <title>
    
      Numpy库的主要使用方法 
      
      
      |
    
     泾流的龙窝
  </title>

  
    <link rel="apple-touch-icon" href="/images/favicon.PNG">
    <link rel="icon" href="/images/favicon.PNG">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <!-- 代码块风格 -->
  
    
<link rel="stylesheet" href="/css/figcaption/mac-block.css">

  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img no-lazy src="/images/avatar.PNG" alt="">
      
    </a>
    <div class="nickname"><a href="/">Zielorem's dragon nest</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">主页</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">标签</a>
        </li>
      
        <li class="nav-item" data-path="/friends/">
          <a href="/friends/">友链</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">关于</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">Numpy库的主要使用方法</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
          2022-10-14 17:52:51
        </span>
        
              <span class="post-tags">
                <i class="iconfont icon-tags mr-10" title="Tags"></i>
                
                <span class="span--tag mr-8">
                  <a href="/tags/python/" title="python">
                    #python
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <p><code>import numpy as np</code></p>
<h1 id="数组属性"><a href="#数组属性" class="headerlink" title="数组属性"></a>数组属性</h1><ul>
<li>Numpy数组（即<code>ndarray</code>）的维度称为秩，一维数组的秩为 1，二维数组的秩为 2</li>
<li>每个线性的数组称为轴（即维度），二维数组相当于两个一维数组，而第一个一维数组中的每个元素又为一个一维数组</li>
<li>对于一维数组，<code>ndarray.axis</code>值仅为 0；对于二维数组，列轴（纵轴）的<code>ndarray.axis</code>值为 0，行轴（横轴）的<code>ndarray.axis</code>值为 1；对于三维数组，<code>ndarray.axis</code>的值为 0、1、2 时分别对应数组的第一维（第一层数组）、第二维（第二层数组）、第三维（第三层数组），第一层数组的元素是第二层数组，第二层数组的元素是第三层数组<table>
<thead>
<tr>
<th align="left">属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>ndarray.ndim</code></td>
<td>秩（维度或轴的数量）</td>
</tr>
<tr>
<td align="left"><code>ndarray.shape</code></td>
<td>数组的维度（比如数组的n行m列）</td>
</tr>
<tr>
<td align="left"><code>ndarray.size</code></td>
<td>数组元素总数</td>
</tr>
<tr>
<td align="left"><code>ndarray.axis</code></td>
<td>数组的轴</td>
</tr>
<tr>
<td align="left"><code>ndarray.dtype</code></td>
<td><code>ndarray</code>对象数据类型</td>
</tr>
<tr>
<td align="left"><code>ndarray.itemsize</code></td>
<td><code>ndarray</code>对象元素大小（byte）</td>
</tr>
<tr>
<td align="left"><code>ndarray.flags</code></td>
<td><code>ndarray</code>对象内存信息</td>
</tr>
<tr>
<td align="left"><code>ndarray.real</code></td>
<td><code>ndarray</code>元素实部</td>
</tr>
<tr>
<td align="left"><code>ndarray.imag</code></td>
<td><code>ndarray</code>元素虚部</td>
</tr>
<tr>
<td align="left"><code>ndarray.data</code></td>
<td>实际数组元素缓冲区</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="dtype"><a href="#dtype" class="headerlink" title="dtype"></a>dtype</h2><p><code>numpy.dtype(&lt;object&gt;, &lt;align&gt;, &lt;copy&gt;)</code></p>
<ul>
<li><code>&lt;object&gt;</code>为要转换为的数据类型对象</li>
<li><code>&lt;align&gt;</code>若为<code>True</code>则填充字段使其类似于C的结构体</li>
<li><code>&lt;copy&gt;</code>决定复制dtype对象，若为<code>False</code>则为对内置数据类型对象的引用</li>
<li>字节顺序通过对数据类型预先设定<code>&gt;</code>或<code>&lt;</code>决定，<code>&gt;</code>即大端法（高字节存储在最前的低位地址），<code>&lt;</code>即小端法 (低字节存储在最前的低位地址)<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">bool_</td>
<td align="left">布尔型数据类型（<code>True</code>或<code>False</code>）</td>
</tr>
<tr>
<td align="left">int_</td>
<td align="left">默认的整数类型（类似于C语言中的long，int32或int64）</td>
</tr>
<tr>
<td align="left">intc</td>
<td align="left">与C语言中的int类型一致（一般是int32或int64）</td>
</tr>
<tr>
<td align="left">intp</td>
<td align="left">用于索引的整数类型（类似于C语言中的ssize_t）</td>
</tr>
<tr>
<td align="left">int8</td>
<td align="left">$[-128, 128)$范围内的整数</td>
</tr>
<tr>
<td align="left">int16</td>
<td align="left">$[-32768, 32768)$范围内的整数</td>
</tr>
<tr>
<td align="left">int32</td>
<td align="left">$[-2147483648, 2147483648)$范围内的整数</td>
</tr>
<tr>
<td align="left">int64</td>
<td align="left">$[-9223372036854775808, 9223372036854775808)$范围内的整数</td>
</tr>
<tr>
<td align="left">uint8</td>
<td align="left">$[0, 256)$范围内的无符号整数</td>
</tr>
<tr>
<td align="left">uint16</td>
<td align="left">$[0, 65536)$范围内的无符号整数</td>
</tr>
<tr>
<td align="left">uint32</td>
<td align="left">$[0, 4294967296)$范围内的无符号整数</td>
</tr>
<tr>
<td align="left">uint64</td>
<td align="left">$[0, 18446744073709551616)$范围内的无符号整数</td>
</tr>
<tr>
<td align="left">float_</td>
<td align="left">float64类型的简写</td>
</tr>
<tr>
<td align="left">float16</td>
<td align="left">半精度浮点数(包括1个符号位，5个指数位，10个尾数位)</td>
</tr>
<tr>
<td align="left">float32</td>
<td align="left">单精度浮点数(包括1个符号位，8个指数位，23个尾数位)</td>
</tr>
<tr>
<td align="left">float64</td>
<td align="left">双精度浮点数(包括1个符号位，11个指数位，52个尾数位)</td>
</tr>
<tr>
<td align="left">complex_</td>
<td align="left">complex128类型的简写（即128位复数）</td>
</tr>
<tr>
<td align="left">complex64</td>
<td align="left">复数，表示双32位浮点数（实数部分和虚数部分）</td>
</tr>
<tr>
<td align="left">complex128</td>
<td align="left">复数，表示双64位浮点数（实数部分和虚数部分）</td>
</tr>
</tbody></table>
</li>
</ul>
<p>每个内建类型都有一个唯一定义它的字符代码</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>对应类型</th>
</tr>
</thead>
<tbody><tr>
<td>b</td>
<td>布尔型</td>
</tr>
<tr>
<td>i</td>
<td>整型（有符号）</td>
</tr>
<tr>
<td>u</td>
<td>整型（无符号）</td>
</tr>
<tr>
<td>f</td>
<td>浮点型</td>
</tr>
<tr>
<td>c</td>
<td>复数浮点型</td>
</tr>
<tr>
<td>m</td>
<td>timedelta（时间间隔）</td>
</tr>
<tr>
<td>M</td>
<td>datetime（日期时间）</td>
</tr>
<tr>
<td>O</td>
<td>Python对象</td>
</tr>
<tr>
<td>S, a</td>
<td>字符串（byte-）</td>
</tr>
<tr>
<td>U</td>
<td>Unicode</td>
</tr>
<tr>
<td>V</td>
<td>原始数据(void)</td>
</tr>
</tbody></table>
<p>比如int8、int16、int32、int64四种数据类型可使用字符’i1’、’i2’、’i4’、’i8’代替</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data1 = np.dtype(<span class="string">&#x27;i4&#x27;</span>)  <span class="comment"># 相当于int32</span></span><br><span class="line">data2 = np.dtype(<span class="string">&#x27;&lt;i2&#x27;</span>)  <span class="comment"># 标注小端法</span></span><br></pre></td></tr></table></figure>

<p>或通过dtype定义结构化数据类型（结构体）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">student = np.dtype([(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;S20&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;i1&#x27;</span>), (<span class="string">&#x27;grade&#x27;</span>, <span class="string">&#x27;f4&#x27;</span>)]) </span><br><span class="line">data = np.array([(<span class="string">&#x27;Alice&#x27;</span>, <span class="number">21</span>, <span class="number">50</span>),(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">18</span>, <span class="number">75</span>)], dtype = student) </span><br><span class="line"><span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure>

<p><strong>切换<code>ndarray</code>中每个元素字节的大端与小端</strong><br><code>numpy.ndarray.byteswap(&lt;inplace&gt;)</code></p>
<ul>
<li><code>&lt;inplace&gt;</code>默认为<code>False</code>，若为<code>True</code>则就地交换字节</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">8</span>, <span class="number">256</span>, <span class="number">16</span>], dtype=np.int16)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">map</span>(<span class="built_in">hex</span>, a), end=<span class="string">&#x27;\n\n&#x27;</span>)  <span class="comment"># &lt;map object at 0x7fcad80b4dc0&gt;</span></span><br><span class="line"><span class="built_in">print</span>(a.byteswap(<span class="literal">True</span>), end=<span class="string">&#x27;\n\n&#x27;</span>)  <span class="comment"># [2048, 1, 4096]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">map</span>(<span class="built_in">hex</span>, a))  <span class="comment"># &lt;map object at 0x7fcae81ce890&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h1><p><code>numpy.array(&lt;object&gt;, &lt;dtype&gt;, &lt;copy&gt;, &lt;order&gt;, &lt;subok&gt;, &lt;ndmin&gt;)</code></p>
<ul>
<li><code>&lt;object&gt;</code>为数组或嵌套的数列</li>
<li><code>&lt;dtype&gt;</code>决定了数组元素的数据类型、数据大小、数据字节顺序等</li>
<li><code>&lt;order&gt;</code>决定创建数组的样式，默认为 A（任意方向），同时 C 为行方向，F 为列方向</li>
<li><code>&lt;subok&gt;</code>默认返回一个与基类类型一致的数组</li>
<li><code>&lt;ndmin&gt;</code>指定生成数组的最小维度<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr1 = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment"># 一维数组</span></span><br><span class="line">arr2 = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]) <span class="comment"># 二维数组</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>从已存在的数组创建新数组</strong><br><code>numpy.asarray(&lt;object&gt;, &lt;dtype&gt;, &lt;order&gt;)</code></p>
<ul>
<li><code>&lt;object&gt;</code>为任意形式的输入参数（列表、元组、多维数组等）</li>
<li><code>&lt;dtype&gt;</code>决定返回数组的数据类型</li>
<li><code>&lt;order&gt;</code>决定数据在计算机内存中存储元素的顺序，若为’C’则为行优先，为’F’则为列优先<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>)]</span><br><span class="line">a = np.asarray(x, dtype = <span class="built_in">float</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>接受buffer输入参数，以流的形式读入转化为ndarray对象，从而实现动态数组</strong><br><code>numpy.frombuffer(&lt;buffer&gt;, &lt;dtype&gt;, &lt;count&gt;, &lt;offset&gt;)</code></p>
<ul>
<li><code>&lt;buffer&gt;</code>以流的形式读入，可以为任意对象</li>
<li><code>&lt;dtype&gt;</code>决定返回数组的数据类型</li>
<li><code>&lt;count&gt;</code>决定读取的数据数量，默认为 -1（读取所有数据）</li>
<li><code>&lt;offset&gt;</code>决定读取的起始位置，默认为 0</li>
<li><code>&lt;buffer&gt;</code>为字符串时，Python3默认str为Unicode类型，需转为bytestring（即在原str前加b）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">b&#x27;Kemono&#x27;</span> <span class="comment"># 转换为bytestring</span></span><br><span class="line">a = np.frombuffer(s, dtype = <span class="string">&#x27;S1&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>从可迭代对象中建立ndarray对象，返回一维数组</strong><br><code>numpy.fromiter(&lt;iterable&gt;, &lt;dtype&gt;, &lt;count&gt;)</code></p>
<ul>
<li><code>&lt;iterable&gt;</code>为可迭代对象</li>
<li><code>&lt;dtype&gt;</code>决定返回数组的数据类型</li>
<li><code>&lt;count&gt;</code>决定读取的数据数量，默认为 -1（读取所有数据）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>) <span class="comment"># 生成迭代器</span></span><br><span class="line"></span><br><span class="line">x = np.fromiter(it, dtype = <span class="built_in">float</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>以指定数值范围创建数组</strong><br><code>numpy.arange(&lt;start&gt;, &lt;stop&gt;, &lt;step&gt;, &lt;dtype&gt;)</code></p>
<ul>
<li><code>&lt;start&gt;</code>决定序列起始位（缺省为 0）</li>
<li><code>&lt;stop&gt;</code>决定序列终止位（不包含该位）</li>
<li><code>&lt;step&gt;</code>决定步长（缺省为 1）</li>
<li><code>&lt;dtype&gt;</code>决定返回数组的数据类型<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr1 = np.arange(<span class="number">5</span>, dtype = <span class="built_in">float</span>) <span class="comment"># [0. 1. 2. 3. 4.]</span></span><br><span class="line">arr2 = np.arange(<span class="number">10</span>, <span class="number">20</span>, <span class="number">2</span>) <span class="comment"># [10 12 14 16 18]</span></span><br><span class="line"><span class="built_in">print</span>(arr1, arr2)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>创建一维等差数组</strong><br><code>np.linspace(&lt;start&gt;, &lt;stop&gt;, &lt;num&gt;, &lt;endpoint&gt;, &lt;retstep&gt;, &lt;dtype&gt;)</code></p>
<ul>
<li><code>&lt;start&gt;</code>决定序列起始位</li>
<li><code>&lt;stop&gt;</code>决定序列终止位</li>
<li><code>&lt;num&gt;</code>决定生成的等步长的样本数量（缺省为 50）</li>
<li><code>&lt;endpoint&gt;</code>（默认）为<code>True</code>时，序列中包含<code>&lt;stop&gt;</code>值，反之不包含</li>
<li><code>&lt;retstep&gt;</code>为<code>True</code>时，生成的数组中将显示间距，反之不显示</li>
<li><code>&lt;dtype&gt;</code>决定返回数组的数据类型<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.linspace(<span class="number">1</span>, <span class="number">1</span>, <span class="number">10</span>)  <span class="comment"># 十个1组成的序列</span></span><br><span class="line">b = np.linspace(<span class="number">10</span>, <span class="number">20</span>, <span class="number">5</span>, endpoint = false, retstep = <span class="literal">True</span>)</span><br><span class="line"><span class="comment"># [10., 12., 14., 16., 18.]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>创建一维等比数组</strong><br><code>np.logspace(&lt;start&gt;, &lt;stop&gt;, &lt;num&gt;, &lt;endpoint&gt;, &lt;base&gt;, &lt;dtype&gt;)</code></p>
<ul>
<li><code>&lt;start&gt;</code>决定序列起始位为<code>base ** start</code></li>
<li><code>&lt;stop&gt;</code>决定序列终止位为<code>base ** stop</code></li>
<li><code>&lt;num&gt;</code>决定生成的等步长的样本数量（缺省为 50）</li>
<li><code>&lt;endpoint&gt;</code>（默认）为<code>True</code>时，序列中包含<code>&lt;stop&gt;</code>值，反之不包含</li>
<li><code>&lt;base&gt;</code>决定序列底数（缺省为 10）</li>
<li><code>&lt;dtype&gt;</code>决定返回数组的数据类型<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.logspace(<span class="number">1</span>, <span class="number">4</span>, num = <span class="number">4</span>)  <span class="comment"># [10. 100. 1000. 10000.]</span></span><br><span class="line">b = np.logspace(<span class="number">0</span>, <span class="number">5</span>, <span class="number">5</span>, endpoint = <span class="literal">False</span>, base = <span class="number">2</span>)  <span class="comment"># [1. 2. 4. 8. 16.]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>创建一个指定形状与数据类型且未初始化的空数组</strong><br><code>numpy.empty(&lt;shape&gt;, &lt;dtype&gt;, &lt;order&gt;)</code></p>
<ul>
<li><code>&lt;shape&gt;</code>为决定数组形状的整数或整数元组</li>
<li><code>&lt;dtype&gt;</code>决定返回数组的数据类型</li>
<li><code>&lt;order&gt;</code>决定数据在计算机内存中存储元素的顺序，若为’C’则为行优先，为’F’则为列优先</li>
<li>数组元素未初始化，因此内容为内存中的随机值</li>
</ul>
<p><strong>创建指定大小的以 0 或 1 填充的数组</strong><br><code>numpy.zeros(&lt;shape&gt;, &lt;dtype&gt;, &lt;order&gt;)</code><br><code>numpy.ones(&lt;shape&gt;, &lt;dtype&gt;, &lt;order&gt;)</code></p>
<ul>
<li><code>&lt;shape&gt;</code>为决定数组形状的整数或整数元组</li>
<li><code>&lt;dtype&gt;</code>决定返回数组的数据类型，缺省为浮点数</li>
<li><code>&lt;order&gt;</code>若为’C’则用于C的行数组，为’F’则用于FORTRAN的列数组<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.empty([<span class="number">3</span>, <span class="number">2</span>], dtype = <span class="built_in">int</span>)  <span class="comment"># 三行两列空二维数组</span></span><br><span class="line">b = np.zeros(<span class="number">2</span>, <span class="number">2</span>)  <span class="comment"># 两行两列全零二维数组</span></span><br><span class="line">c = np.ones(<span class="number">2</span>, <span class="number">2</span>)  <span class="comment"># 两行两列全一二维数组</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>创建以1填充对角线元素的二维等长数组（类似单位矩阵）</strong><br><code>np.eye(&lt;column&gt;, &lt;row&gt;, &lt;index&gt;, &lt;dtype&gt;)</code></p>
<ul>
<li><code>&lt;column&gt;</code>决定二维数组行数</li>
<li><code>&lt;row&gt;</code>决定二维数组列数（默认与行数一致）</li>
<li><code>&lt;index&gt;</code>决定对角线的索引</li>
<li><code>&lt;dtype&gt;</code>决定数组返回元素的类型</li>
</ul>
<p><strong>创建对角数组</strong><br><code>np.diag(&lt;array_like&gt;, &lt;diagonal_position&gt;)</code></p>
<ul>
<li><code>&lt;array_like&gt;</code>若为二维数组，则返回<code>&lt;diagonal_position&gt;</code>位置的对角线；若为一维数组，则返回一个<code>&lt;array_like&gt;</code>作为<code>&lt;diagonal_position&gt;</code>位置对角线的二维数组</li>
<li><code>&lt;diagonal_position&gt;</code>决定对角线位置，若大于 0 则上移，反之下移<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = np.eye(<span class="number">2</span>)  <span class="comment"># 以1填充对角元素的二维两行两列数组</span></span><br><span class="line"></span><br><span class="line">y = np.arange(<span class="number">9</span>).reshape((<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">arr1 = np.diag(y)  <span class="comment"># [0, 4, 8]</span></span><br><span class="line">arr2 = np.diag(y, -<span class="number">1</span>)  <span class="comment"># [3, 7]</span></span><br><span class="line">z = np.diag(np.diag(arr1))  <span class="comment"># 以[0, 4, 8]为对角元素的三行三列对角矩阵</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>给定形状的以随机样本 $[0, 1)$ 中的随机元素填充的数组</strong><br><code>np.random.rand(&lt;size&gt;)</code></p>
<p><strong>给定形状的以服从标准正态分布的一个或一组元素填充的数组</strong><br><code>np.random.randn(&lt;size&gt;)</code> </p>
<p><strong>给定形状的以给定范围内的随机整数填充的数组</strong><br><code>np.random.randint(&lt;low&gt;, &lt;high&gt;, &lt;size&gt;, &lt;dtype&gt;)</code></p>
<ul>
<li><code>&lt;low&gt;</code>决定起始位</li>
<li><code>&lt;high&gt;</code>决定终止位（不包含），未赋值时整数范围为 $[0, low)$</li>
<li><code>&lt;size&gt;</code>决定整数数组形状</li>
<li><code>&lt;dtype&gt;</code>决定整数类型</li>
</ul>
<p><strong>给定形状的以 $[0, 1)$ 范围内的随机浮点数填充的数组</strong><br><code>np.random.random(&lt;size&gt;)</code></p>
<p><strong>给定形状的以给定一维数组内的元素随机填充的数组</strong><br><code>np.random.choice(&lt;array&gt;, &lt;size&gt;, &lt;replace&gt;, &lt;p&gt;)</code></p>
<ul>
<li><code>&lt;array&gt;</code>为给定的一维数组</li>
<li><code>&lt;size&gt;</code>决定输出数组形状</li>
<li><code>&lt;replace&gt;</code>决定一维数组中的元素可否被多次选中，默认为<code>True</code></li>
<li><code>&lt;p&gt;</code>决定一维数组中各元素被选中的概率，形状必须与<code>&lt;array&gt;</code>一致</li>
</ul>
<p><strong>以seed值标记特定随机数序列</strong><br><code>np.random.seed(&lt;seed&gt;)</code></p>
<ul>
<li>在相同seed值下所生成的随机数序列为同一批</li>
<li>调用其他方法生成随机数前，调用此方法可通过seed值标记特定随机数序列或采用已通过seed值标记的特定随机数序列</li>
</ul>
<h1 id="切片与索引"><a href="#切片与索引" class="headerlink" title="切片与索引"></a>切片与索引</h1><p><strong>通过内置的<code>slice</code>函数从原数组中切割出新数组</strong><br><code>slice(&lt;start&gt;, &lt;stop&gt;, &lt;step&gt;)</code></p>
<ul>
<li><code>&lt;start&gt;</code>决定切割起始位</li>
<li><code>&lt;stop&gt;</code>决定切割终止位</li>
<li><code>&lt;step&gt;</code>决定切割间隔数值</li>
<li>Python切片时复制数组并操作，而Numpy切片时直接操作原数组</li>
</ul>
<p>或通过冒号分割切片参数<code>start:stop:step</code>进行切片操作</p>
<p>切片可以通过省略号使得所选元组的长度与数组的维度相同，若在行位置使用省略号，其将返回包含行中元素的ndarray</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">10</span>)</span><br><span class="line">s1 = <span class="built_in">slice</span>(<span class="number">2</span>, <span class="number">7</span>, <span class="number">2</span>) <span class="comment"># 从索引2开始至索引7终止，间隔为2</span></span><br><span class="line">b = a[<span class="number">2</span>:<span class="number">7</span>:<span class="number">2</span>] <span class="comment"># a == b</span></span><br><span class="line"></span><br><span class="line">c = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(c[<span class="number">1</span>,...]) <span class="comment"># 第二行元素</span></span><br><span class="line"><span class="built_in">print</span>(c[...,<span class="number">1</span>:]) <span class="comment"># 第二列及剩下所有列元素</span></span><br></pre></td></tr></table></figure>

<p><strong>返回数组中（沿特定轴）的最大元素与最小元素的索引值</strong><br><code>numpy.argmax(&lt;array&gt;, &lt;axis&gt;)</code><br><code>numpy.argmin(&lt;array&gt;, &lt;axis&gt;)</code></p>
<p><strong>返回数组中非零元素的索引值</strong><br><code>numpy.nonzero(&lt;array&gt;)</code></p>
<p><strong>返回数组中满足给定条件的元素</strong><br><code>numpy.extract(&lt;condition&gt;)</code></p>
<p><strong>返回数组中满足给定条件的元素的索引值</strong><br><code>numpy.where(&lt;condition&gt;)</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">30</span>, <span class="number">40</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">20</span>, <span class="number">10</span>], [<span class="number">50</span>, <span class="number">0</span>, <span class="number">60</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.nonzero(a))  <span class="comment"># (array([0, 0, 1, 1, 2, 2]), array([0, 1, 1, 2, 0, 2]))</span></span><br><span class="line"><span class="built_in">print</span>(np.where(a &gt; <span class="number">35</span>))  <span class="comment"># (array([0, 2, 2]), array([1, 0, 2]))</span></span><br><span class="line"><span class="built_in">print</span>(np.extract(np.mod(a, <span class="number">3</span>) == <span class="number">0</span>, a))  <span class="comment"># [30, 0, 0, 0, 60]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="整数数组索引"><a href="#整数数组索引" class="headerlink" title="整数数组索引"></a>整数数组索引</h2><p>可以借助切片<code>:</code>或<code>...</code>与索引数组组合</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]])</span><br><span class="line">y = x[[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]] <span class="comment">#[1, 4, 5]</span></span><br><span class="line"></span><br><span class="line">a = x[<span class="number">1</span>:<span class="number">3</span>, <span class="number">1</span>:<span class="number">3</span>] <span class="comment"># [[4, 5], [6, 7]]</span></span><br><span class="line">b = x[<span class="number">1</span>:<span class="number">3</span>, [<span class="number">1</span>, <span class="number">2</span>]] <span class="comment"># a == b</span></span><br><span class="line">c = a[...,<span class="number">1</span>:] <span class="comment"># [[2, 3], [4, 5], [6, 7]]</span></span><br></pre></td></tr></table></figure>

<h2 id="布尔索引"><a href="#布尔索引" class="headerlink" title="布尔索引"></a>布尔索引</h2><p><strong>通过一个布尔数组索引目标数组</strong><br>布尔索引通过布尔运算获取符合指定条件的元素的数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"><span class="built_in">print</span>(x[x &gt; <span class="number">5</span>]) <span class="comment"># [6, 7, 8, 9, 10, 11]</span></span><br></pre></td></tr></table></figure>

<p>使用<code>~</code>(取补运算符)过滤<code>NaN</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([np.nan, <span class="number">1</span>, <span class="number">2</span>, np.nan, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(a[~np.isnan(a)]) <span class="comment"># [1. 2. 3. 4. 5.]</span></span><br><span class="line"></span><br><span class="line">b = np.array([<span class="number">1</span>, <span class="number">2</span>+<span class="number">6j</span>, <span class="number">5</span>, <span class="number">3.5</span>+<span class="number">5j</span>])</span><br><span class="line"><span class="built_in">print</span>(a[np.iscomplex(a)]) <span class="comment"># [2+6j, 3.5+5j]</span></span><br></pre></td></tr></table></figure>

<p>存在多个条件时，将条件加以小括号或使用<code>np.logical_and</code>与<code>np.all</code>方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x[(x &gt; <span class="number">5</span>) &amp; (x &lt; <span class="number">7</span>)]) <span class="comment"># 条件加小括号分割</span></span><br><span class="line"><span class="built_in">print</span>(x[np.logical_and(x &gt; <span class="number">5</span>, x &lt; <span class="number">7</span>)]) <span class="comment"># 使用np.logical方法</span></span><br><span class="line"><span class="built_in">print</span>(x[np.<span class="built_in">all</span>([x &gt; <span class="number">5</span>, x &lt; <span class="number">7</span>], axis=<span class="number">0</span>)]) <span class="comment"># 使用np.all方法</span></span><br></pre></td></tr></table></figure>

<h2 id="花式索引"><a href="#花式索引" class="headerlink" title="花式索引"></a>花式索引</h2><p><strong>将整数数组的值作为目标数组的某轴下标进行索引</strong><br>对于使用一维整型数组作为索引：</p>
<ul>
<li>若目标为一维数组，则索引结果为对应位置元素</li>
<li>若目标为二维数组，则索引结果为对应下标的行</li>
<li>将数据复制到新数组中<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(<span class="number">1</span>, <span class="number">9</span>)</span><br><span class="line">a = x[[<span class="number">0</span>, <span class="number">6</span>]] <span class="comment"># [1, 7]</span></span><br><span class="line"></span><br><span class="line">y = np.arange(<span class="number">9</span>).reshape((<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">b = x[[<span class="number">1</span>, <span class="number">0</span>]] <span class="comment"># [[3, 4, 5], [0, 1, 2]]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>传入多个索引数组需使用<code>np.ix_</code>，即输入两个数组产生笛卡尔积的映射关系</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(<span class="number">9</span>).reshape((<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(x[np.ix_([<span class="number">2</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">2</span>])]) <span class="comment"># [[6, 8], [3, 5]]</span></span><br></pre></td></tr></table></figure>

<h1 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h1><p><strong>对不同形状的数组进行数值计算的方式（即矩阵运算）</strong><br>若两个数组 x 与 y 形状相同，即<code>x.shape == y.shape</code>，则 a 与 b 相乘的结果为 a 与 b 数组对位相乘（维数相同且各维度长度相同）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">b = np.array([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">c = a * b</span><br><span class="line"><span class="built_in">print</span>(c) <span class="comment"># [2, 6, 12, 20]</span></span><br></pre></td></tr></table></figure>

<p>若两个数组 x 与 y 形状不同，即<code>x.shape != y.shape</code>，则将触发广播机制</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>], [<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>], [<span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>]])</span><br><span class="line">b = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(a + b) <span class="comment"># [[0, 1, 2], [10, 11, 12], [20, 21, 22], [30, 31, 32]]</span></span><br></pre></td></tr></table></figure>

<p><strong>返回封装了一数组广播到另一数组的结果，并模仿广播对象</strong><br><code>numpy.broadcast(&lt;arr1&gt;, &lt;arr2&gt;)</code></p>
<p><strong>将数组广播到新形状，并在原数组上返回只读视图，通常不连续</strong><br><code>numpy.broadcast_to(&lt;array&gt;, &lt;shape&gt;)</code></p>
<ul>
<li><code>&lt;array&gt;</code>为原数组</li>
<li><code>&lt;shape&gt;</code>为新形状</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(<span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>, dtype=<span class="built_in">int</span>)</span><br><span class="line">y = np.array([[<span class="number">1</span>], [<span class="number">3</span>], [<span class="number">5</span>]])</span><br><span class="line"></span><br><span class="line">b = np.broadcast(x, y) <span class="comment"># 返回广播对象</span></span><br><span class="line">row, column = b.iters <span class="comment"># 两个flatiter对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 广播的前两步对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(row), <span class="built_in">next</span>(column)) <span class="comment"># (4, 1)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(row), <span class="built_in">next</span>(column)) <span class="comment"># (4, 3)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">c = np.empty(b.shape) <span class="comment">#3 *3大小的空数组</span></span><br><span class="line">c.flat = [i + j <span class="keyword">for</span> (i,j) <span class="keyword">in</span> b] <span class="comment"># [[5, 7, 9], [6, 8, 10], [7, 9, 11]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.broadcast_to(x, (<span class="number">2</span>, <span class="number">3</span>))) <span class="comment"># [[4, 5, 6], [4, 5, 6]]</span></span><br></pre></td></tr></table></figure>

<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>提供灵活访问一个或多个数组元素的方法，迭代选择顺序与数据内存布局一致，<strong>缺省行序优先</strong><br><code>np.nditer(&lt;array_like&gt;, &lt;flags&gt;, &lt;op_flags&gt;, &lt;order&gt;)</code></p>
<ul>
<li><code>&lt;array_like&gt;</code>为需要迭代的序列</li>
<li><code>&lt;flags&gt;</code>用于控制迭代器行为<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>buffered</code></td>
<td>在需要时启用缓冲</td>
</tr>
<tr>
<td><code>c_index</code></td>
<td>跟踪C顺序索引</td>
</tr>
<tr>
<td><code>f_index</code></td>
<td>跟踪Fortran顺序索引</td>
</tr>
<tr>
<td><code>multi_index</code></td>
<td>跟踪多个索引或每次迭代跟踪一种索引(多维索引)</td>
</tr>
<tr>
<td><code>external_loop</code></td>
<td>所给值为具有多个值的一维数组而非零维数组</td>
</tr>
</tbody></table>
</li>
<li><code>&lt;op_flags&gt;</code>指定每个操作的特征，缺省状态下待迭代数组状态为’read-only’，若在遍历迭代数组的同时修改数组元素则需指定为’readwrite’或’writeonly’</li>
<li><code>&lt;order&gt;</code>用于控制迭代顺序，’C’为行序优先，’F’为列序优先<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">6</span>).reshape(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代输出数组元素</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a):</span><br><span class="line">	<span class="built_in">print</span>(x, end = <span class="string">&#x27;, &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>) <span class="comment"># [0, 1, 2, 3, 4, 5,]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代输出转置数组元素</span></span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> np.nditer(a.T):</span><br><span class="line">	<span class="built_in">print</span>(y, end = <span class="string">&#x27;, &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>) <span class="comment"># [0, 1, 2, 3, 4, 5,]</span></span><br><span class="line"><span class="comment"># y在转置后元素在内存中的存储顺序仍与x一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以行序优先模式迭代输出转置数组的元素</span></span><br><span class="line"><span class="keyword">for</span> z <span class="keyword">in</span> np.nditer(a.T, order = <span class="string">&#x27;C&#x27;</span>):</span><br><span class="line">	<span class="built_in">print</span>(z, end = <span class="string">&#x27;, &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>) <span class="comment"># [0, 3, 1, 4, 2, 5,]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改数组元素</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a, op_flags=<span class="string">&#x27;readwrite&#x27;</span>):</span><br><span class="line">	x[...] = <span class="number">2</span>*x</span><br><span class="line"><span class="built_in">print</span>(x) <span class="comment"># [0, 2, 4, 6, 8, 10,]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加索引</span></span><br><span class="line">it = np.nditer(x, flags=[<span class="string">&#x27;multi_index&#x27;</span>])</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> it.finished:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;%d&lt;%s&gt;&quot;</span>%(it[<span class="number">0</span>], it.multi_index)) <span class="comment">#生成二维index</span></span><br><span class="line">	it.iternext() <span class="comment"># 进入下一次迭代</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加外部循环(对应于每列并组合为一维数组)</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(x, flags=[<span class="string">&#x27;external_loop&#x27;</span>], order=<span class="string">&#x27;F&#x27;</span>):</span><br><span class="line">	<span class="built_in">print</span>(x, end=<span class="string">&#x27;, &#x27;</span>) <span class="comment">#[[0, 2], [4, 6], [8, 10]]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>nditer</code>可同时迭代两个可广播数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], dtype=<span class="built_in">int</span>)</span><br><span class="line">b = np.arange(<span class="number">0</span>, <span class="number">60</span>, <span class="number">5</span>).reshape(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> x,y <span class="keyword">in</span> np.nditer([a,b]):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;%d:%d&#x27;</span> % (x,y), end=<span class="string">&#x27;, &#x27;</span>)</span><br><span class="line">	<span class="comment"># 1:0, 2:5, 3:10, 4:15, 1:20, 2:25, 3:30, 4:35, 1:40, 2:45, 3:50, 4:55</span></span><br></pre></td></tr></table></figure>

<h1 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h1><p><strong>在不改变原始数据的情况下修改数组形状</strong><br><code>numpy.reshape(&lt;array&gt;, &lt;newshape&gt;, &lt;order&gt;)</code></p>
<ul>
<li><code>&lt;array&gt;</code>为需要修改形状的数组</li>
<li><code>&lt;newshape&gt;</code>为整数或整数数组（应兼容原数组形状）</li>
<li><code>&lt;order&gt;</code>决定元素的排列顺序<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>‘C’</td>
<td>按行排列</td>
</tr>
<tr>
<td>‘F’</td>
<td>按列排列</td>
</tr>
<tr>
<td>‘A’</td>
<td>按数组原顺序排列</td>
</tr>
<tr>
<td>‘K’</td>
<td>按元素在内存中的存储顺序排列</td>
</tr>
</tbody></table>
</li>
</ul>
<p><strong>对数组中各元素进行处理（数组元素迭代器）</strong><br><code>numpy.ndarray.flat()</code></p>
<p><strong>返回一份展开的数组拷贝并独立于原数组</strong><br><code>numpy.ndarray.flatten(&lt;order&gt;)</code></p>
<ul>
<li><code>&lt;order&gt;</code>决定元素的排列顺序（同<code>reshape()</code>）</li>
<li>对拷贝所进行的修改不会影响原数组</li>
</ul>
<p><strong>返回一份展开的数组视图</strong><br><code>numpy.ravel(&lt;array&gt;, &lt;order&gt;)</code></p>
<ul>
<li><code>&lt;array&gt;</code>为需要进行操作的数组</li>
<li><code>&lt;order&gt;</code>决定元素的排列顺序（同<code>reshape()</code>）</li>
<li>对视图进行的修改会影响原数组<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> elements <span class="keyword">in</span> a.flat:</span><br><span class="line">	<span class="built_in">print</span>(element) <span class="comment">#依次输出数组中元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按列优先顺序展开数组</span></span><br><span class="line"><span class="built_in">print</span>(a.flatten(order=<span class="string">&#x27;F&#x27;</span>), end=<span class="string">&#x27;, &#x27;</span>) <span class="comment"># [0, 3, 6, 1, 4, 7, 2, 5, 8, ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以行优先顺序展开数组</span></span><br><span class="line"><span class="built_in">print</span>(a.ravel(order=<span class="string">&#x27;C&#x27;</span>), end=<span class="string">&#x27;, &#x27;</span>) <span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, ]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>对换数组维度（转置）</strong><br><code>numpy.transpose(&lt;array&gt;, &lt;axes&gt;)</code></p>
<ul>
<li><code>&lt;array&gt;</code>为需要对换数组维度的数组</li>
<li><code>&lt;axes&gt;</code>为对应维度的整数列表（通常对换所有维度）</li>
<li>类似于<code>numpy.ndarray.T</code></li>
</ul>
<p><strong>向后滚动特定数组坐标轴</strong><br><code>numpy.rollaxis(&lt;array&gt;, &lt;axis&gt;, &lt;start&gt;)</code></p>
<ul>
<li><code>&lt;array&gt;</code>为需要对坐标轴执行向后滚动操作的数组</li>
<li><code>&lt;axis&gt;</code>为需要向后滚动的轴</li>
<li><code>&lt;start&gt;</code>表示需要滚动至的特定位置，缺省为 0（第 0 个轴）</li>
<li>其他轴的相对位置不会改变</li>
</ul>
<p><strong>对换数组的两个坐标轴</strong><br><code>numpy.swapaxes(&lt;array&gt;, &lt;axis1&gt;, &lt;axis2&gt;)</code></p>
<ul>
<li><code>&lt;array&gt;</code>为需要执行对换坐标轴操作的数组</li>
<li><code>&lt;axis1&gt;</code>、<code>&lt;axis2&gt;</code>为对应两个轴的整数序号</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">8</span>).reshape(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">b = np.rollaxis(a, <span class="number">2</span>, <span class="number">0</span>) <span class="comment"># 轴2（宽度）滚动至轴0（深度）的位置</span></span><br><span class="line">c = np.swapaxes(a, <span class="number">2</span>, <span class="number">0</span>) <span class="comment"># 轴2（宽度）与轴0（深度）互换位置</span></span><br></pre></td></tr></table></figure>

<p><strong>在指定位置插入新轴以扩展数组</strong><br><code>numpy.expand_dims(&lt;array&gt;, &lt;axis&gt;)</code></p>
<ul>
<li><code>&lt;array&gt;</code>为执行数组</li>
<li><code>&lt;axis&gt;</code>为新轴所插入位置</li>
</ul>
<p><strong>在指定数组中删除值为1的维度</strong><br><code>numpy.squeeze(&lt;array&gt;, &lt;axis&gt;)</code></p>
<ul>
<li><code>&lt;array&gt;</code>为执行数组</li>
<li><code>&lt;axis&gt;</code>用于指定需要删除的维度（单维度），取值为<code>None</code>、<code>int</code>或<code>tuple of ints</code>，取值为空时删除所有值为 1 的维度（单维度）</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(<span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>, dtype=<span class="built_in">int</span>)</span><br><span class="line">y = np.array([[<span class="number">1</span>], [<span class="number">3</span>], [<span class="number">5</span>]])</span><br><span class="line"></span><br><span class="line">z = np.expand_dims(y, axis=<span class="number">1</span>) <span class="comment"># 在位置1插入新轴</span></span><br><span class="line"><span class="built_in">print</span>(z.shape) <span class="comment"># (3, 1, 1)</span></span><br><span class="line"></span><br><span class="line">z = np.squeeze(z，axis=(<span class="number">2</span>,))</span><br><span class="line"><span class="built_in">print</span>(z.shape) <span class="comment"># (3, 1)</span></span><br></pre></td></tr></table></figure>

<p><strong>沿指定轴连接相同形状的两个或多个数组</strong><br><code>numpy.concatenate(&lt;arrays&gt;, &lt;axis&gt;)</code></p>
<ul>
<li><code>&lt;arrays&gt;</code>为同类型同形状的数组</li>
<li><code>&lt;axis&gt;</code>指定连接数组的轴（缺省为 0，上下连接），若值为 1 则左右连接</li>
</ul>
<p><strong>沿新轴合并一系列数组</strong><br><code>numpy.stack(&lt;arrays&gt;, &lt;axis&gt;)</code></p>
<ul>
<li><code>&lt;arrays&gt;</code>为同类型同形状的数组</li>
<li><code>&lt;axis&gt;</code>指定数组序列的堆叠方向<table>
<thead>
<tr>
<th>axis值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>axis&#x3D;0</td>
<td>在最外层括号执行堆叠</td>
</tr>
<tr>
<td>axis&#x3D;1</td>
<td>在次外层括号执行堆叠</td>
</tr>
<tr>
<td>axis&#x3D;2</td>
<td>(三维数组中)在最内层括号内执行堆叠</td>
</tr>
</tbody></table>
</li>
<li>堆叠后的数组比原数组多一个维度</li>
</ul>
<p><strong>通过水平堆叠生成数组</strong><br><code>numpy.hstack(&lt;arrays&gt;)</code></p>
<ul>
<li><code>&lt;arrays&gt;</code>为同类型同形状的数组</li>
<li>相当于<code>numpy.concatenate()</code>方法中<code>&lt;axis&gt;</code>值为 1</li>
</ul>
<p><strong>通过垂直堆叠生成数组</strong><br><code>numpy.vstack(&lt;arrays&gt;)</code></p>
<ul>
<li><code>&lt;arrays&gt;</code>为同类型同形状的数组</li>
<li>相当于<code>numpy.concatenate()</code>方法中<code>&lt;axis&gt;</code>值为 0</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line">b = np.array([[<span class="number">4</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 沿轴1连接数组a与数组b</span></span><br><span class="line"><span class="built_in">print</span>(np.concatenate((a, b), axis=<span class="number">1</span>), end=<span class="string">&#x27;\n\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.hstack((a, b)), end=<span class="string">&#x27;\n\n&#x27;</span>)</span><br><span class="line"><span class="comment"># [[1, 2, 4, 3], [3, 4, 2, 1]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.concatenate((a, b), axis=<span class="number">0</span>), end=<span class="string">&#x27;\n\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.vstack((a, b)), end=<span class="string">&#x27;\n\n&#x27;</span>)</span><br><span class="line"><span class="comment"># [[1, 2], [3, 4], [4, 3], [2, 1]]</span></span><br><span class="line"></span><br><span class="line">c = np.stack((a, b), axis=<span class="number">0</span>) <span class="comment"># [[[1, 2], [3, 4]], [[4, 3], [2, 1]]]</span></span><br><span class="line"><span class="built_in">print</span>(np.stack((a, b), axis=<span class="number">1</span>)) <span class="comment"># [[[1, 2], [4, 3]], [[3, 4], [2, 1]]]</span></span><br><span class="line"><span class="built_in">print</span>(np.stack(c, axis=<span class="number">2</span>)) <span class="comment"># [[[1, 4], [2, 3]], [[3, 2], [4, 1]]]</span></span><br></pre></td></tr></table></figure>

<p><strong>沿特定轴分割数组</strong><br><code>numpy.split(&lt;array&gt;, &lt;indices_or_sections&gt;, &lt;axis&gt;)</code></p>
<ul>
<li><code>&lt;arrays&gt;</code>为被分割的数组</li>
<li><code>&lt;indices_or_sections&gt;</code>若为整数则将数组均分为该数等份，若为数组则决定沿轴分割位置</li>
<li><code>&lt;axis&gt;</code>决定数组沿着何方向分割，缺省为 0（横向分割），为 1 时纵向分割</li>
</ul>
<p><strong>纵向分割数组</strong><br><code>numpy.hsplit(&lt;array&gt;, &lt;indices_or_sections&gt;)</code></p>
<ul>
<li><code>&lt;arrays&gt;</code>为被分割的数组</li>
<li><code>&lt;indices_or_sections&gt;</code>若为整数则将数组均分为该数等份，若为数组则决定沿轴分割位置</li>
<li>相当于<code>numpy.split()</code>方法中<code>&lt;axis&gt;</code>值为 1</li>
</ul>
<p><strong>横向分割数组</strong><br><code>numpy.vsplit(&lt;array&gt;, &lt;indices_or_sections&gt;)</code></p>
<ul>
<li><code>&lt;arrays&gt;</code>为被分割的数组</li>
<li><code>&lt;indices_or_sections&gt;</code>若为整数则将数组均分为该数等份，若为数组则决定沿轴分割位置</li>
<li>相当于<code>numpy.split()</code>方法中<code>&lt;axis&gt;</code>值为 0<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">b = np.split(a, <span class="number">3</span>)</span><br><span class="line">c = np.split(a, [<span class="number">2</span>, <span class="number">4</span>])</span><br><span class="line"><span class="comment"># [0, 1], [2, 3], [4, 5]</span></span><br><span class="line"></span><br><span class="line">x = np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">y1 = np.split(x, <span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">y2 = np.hsplit(x, [<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="comment"># [[0], [3], [6]], [[1], [4], [7]], [[2], [5], [8]]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>返回指定大小的新数组</strong><br><code>numpy.resize(&lt;array&gt;, &lt;shape&gt;)</code></p>
<ul>
<li><code>&lt;arrays&gt;</code>为需要修改大小的数组</li>
<li><code>&lt;shape&gt;</code>为数组返回的新形状</li>
</ul>
<p><strong>分配整个数组并在数组的末尾追加值（扩展数组）</strong><br><code>numpy.append(&lt;array&gt;, &lt;values&gt;, &lt;axis&gt;)</code></p>
<ul>
<li><code>&lt;arrays&gt;</code>为需要扩展的数组</li>
<li><code>&lt;values&gt;</code>为需要向数组扩展的数组内容（与原数组形状相同）</li>
<li><code>&lt;axis&gt;</code>指定数组扩展方向，默认为<code>None</code>并返回一维数组。若定义值为 0 则纵向扩展（列数需一致），定义值为 1 则横向扩展（行数需一致）</li>
</ul>
<p><strong>在指定索引前沿指定轴在数组中插入值</strong><br><code>numpy.insert(&lt;array&gt;, &lt;index&gt;, &lt;values&gt;, &lt;axis&gt;)</code></p>
<ul>
<li><code>&lt;arrays&gt;</code>为需要插入值的数组</li>
<li><code>&lt;index&gt;</code>为插入位置的索引</li>
<li><code>&lt;values&gt;</code>为需要插入的值</li>
<li><code>&lt;axis&gt;</code>为插入位置所沿的轴，默认展开原数组。若定义值为 0 则横向插入，定义值为 1 则纵向插入</li>
</ul>
<p><strong>在指定索引沿指定轴在数组中删除指定子数组</strong><br><code>numpy.delete(&lt;array&gt;, &lt;index&gt;, &lt;axis&gt;)</code></p>
<ul>
<li><code>&lt;arrays&gt;</code>为需要删除值的数组</li>
<li><code>&lt;index&gt;</code>为删除位置的索引</li>
<li><code>&lt;axis&gt;</code>为删除位置所沿的轴，默认展开原数组。若定义值为 0 则横向删除，定义值为 1 则纵向删除</li>
</ul>
<p><strong>删除数组中重复元素</strong><br><code>numpy.unique(&lt;array&gt;, &lt;return_index&gt;, &lt;return_inverse&gt;, &lt;return_counts&gt;)</code></p>
<ul>
<li><code>&lt;arrays&gt;</code>为需要去重的数组</li>
<li><code>&lt;return_index&gt;</code>若为<code>True</code>，则返回去重后数组内元素在原数组中的索引位置（列表形式）</li>
<li><code>&lt;return_inverse&gt;</code>若为<code>True</code>，则返回原数组内元素在去重后数组中的索引位置（列表形式）</li>
<li><code>&lt;return_counts&gt;</code>若为<code>True</code>，则返回原数组内各元素出现次数<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line">b1 = np.resize(a, (<span class="number">3</span>, <span class="number">2</span>))  <span class="comment"># [[1, 2], [3, 4], [5, 6]]</span></span><br><span class="line">b2 = np.resize(a, (<span class="number">3</span>, <span class="number">3</span>))  <span class="comment"># [[1, 2, 3], [4, 5, 6], [1, 2, 3]]</span></span><br><span class="line"></span><br><span class="line">c1 = np.insert(a, <span class="number">3</span>, [<span class="number">3</span>, <span class="number">4</span>])  <span class="comment"># [1, 2, 3, 3, 4, 4, 5, 6]</span></span><br><span class="line">c2 = np.insert(a, <span class="number">2</span>, [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], axis=<span class="number">0</span>)  <span class="comment"># [[1, 2, 3], [4, 5, 6], [7, 8, 9]]</span></span><br><span class="line">c3 = np.insert(a, [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">9</span>], axis=<span class="number">1</span>)  <span class="comment"># [[1, 9, 2, 9, 3], [4, 9, 5, 9, 6]]</span></span><br><span class="line"></span><br><span class="line">d1 = np.delete(c3, [<span class="number">1</span>, <span class="number">3</span>], axis=<span class="number">1</span>) <span class="comment">#[[1, 2, 3], [4, 5, 6]]</span></span><br><span class="line">d2 = np.delete(a, np.s_[::<span class="number">2</span>]) <span class="comment">#[2, 4, 6]</span></span><br><span class="line"></span><br><span class="line">e, indices = np.unique(c1, return_index=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(e)  <span class="comment"># [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="built_in">print</span>(indices)  <span class="comment"># [0, 1, 2, 4, 5, 6, 7]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p>对数组中整数元素的二进制形式执行位运算</p>
<table>
<thead>
<tr>
<th>运算方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>numpy.bitwise_and(&lt;numbers&gt;)</code></td>
<td>位与运算</td>
</tr>
<tr>
<td><code>numpy.bitwise_or(&lt;numbers&gt;)</code></td>
<td>位或运算</td>
</tr>
<tr>
<td><code>numpy.invert(&lt;number&gt;)</code></td>
<td>取反运算</td>
</tr>
</tbody></table>
<p><strong>将数组中元素的二进制形式左移指定位置，右侧补上相应数量的 0</strong><br><code>numpy.left_shift(&lt;number&gt;，&lt;movement&gt;)</code></p>
<ul>
<li><code>&lt;number&gt;</code>为数组中元素</li>
<li><code>&lt;movement&gt;</code>为数组左移位数</li>
</ul>
<p><strong>将数组中元素的二进制形式右移指定位置，左侧补上相应数量的 0</strong><br><code>numpy.right_shift(&lt;number&gt;，&lt;movement&gt;)</code></p>
<ul>
<li><code>&lt;number&gt;</code>为数组中元素</li>
<li><code>&lt;movement&gt;</code>为数组右移位数</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.bitwise_and(<span class="number">21</span>, <span class="number">25</span>))</span><br><span class="line"><span class="comment"># 0b10101 + 0b11001 == 0b10001 (17)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.bitwise_or(<span class="number">21</span>, <span class="number">25</span>))</span><br><span class="line"><span class="comment"># 0b10101 + 0b11001 == 0b11101 (29)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.invert(<span class="number">7</span>))</span><br><span class="line"><span class="comment"># 原码转二进制 0b00000111</span></span><br><span class="line"><span class="comment"># 按位取反 0b11111000</span></span><br><span class="line"><span class="comment"># 首位为1表示负数，将除符号位外的其他位取反 0b10000111</span></span><br><span class="line"><span class="comment"># (末位加1)取补码 0b10001000</span></span><br><span class="line"><span class="comment"># 转回十进制 -8</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.left_shift(<span class="number">7</span>, <span class="number">3</span>))</span><br><span class="line"><span class="comment"># 0b00000111 --&gt; 0b00111000 (56)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.right_shift(<span class="number">56</span>, <span class="number">3</span>))</span><br><span class="line"><span class="comment"># 0b00111000 --&gt; 0b00000111 (7)</span></span><br></pre></td></tr></table></figure>

<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>numpy.char.add(&lt;strings&gt;)</code></td>
<td>连接两个字符串元素</td>
</tr>
<tr>
<td><code>numpy.char.multiply(&lt;string&gt;)</code></td>
<td>复制某个指定字符串元素并连接（多重连接）</td>
</tr>
<tr>
<td><code>numpy.char.center(&lt;strings&gt;, &lt;length&gt;, &lt;fillchar&gt;)</code></td>
<td>将字符串居中，并指定一个字符在左右两侧填充</td>
</tr>
<tr>
<td><code>numpy.char.capitalize(&lt;strings&gt;)</code></td>
<td>将字符串的首字母转换为大写</td>
</tr>
<tr>
<td><code>numpy.char.title(&lt;strings&gt;)</code></td>
<td>将字符串的每个单词的首字母均转换为大写</td>
</tr>
<tr>
<td><code>numpy.char.upper(&lt;strings&gt;)</code></td>
<td>将字符串的每个元素转换为大写</td>
</tr>
<tr>
<td><code>numpy.char.lower(&lt;strings&gt;)</code></td>
<td>将字符串的每个元素转换为小写</td>
</tr>
<tr>
<td><code>numpy.char.split([&lt;strings&gt;], [&lt;seperates&gt;])</code></td>
<td>指定分隔符（默认空格）分割字符串，并返回数组</td>
</tr>
<tr>
<td><code>numpy.char.splitlines(&lt;strings&gt;)</code></td>
<td>将换行符作为分隔符以分割字符串，并返回数组</td>
</tr>
<tr>
<td><code>numpy.char.strip([&lt;strings&gt;], &lt;char_to_delete&gt;)</code></td>
<td>移除开头处与结尾处的某个指定字符</td>
</tr>
<tr>
<td><code>numpy.char.join([&lt;fill_chars&gt;], [&lt;strings&gt;])</code></td>
<td>指定分隔符填充字符串中字符间的间隔</td>
</tr>
<tr>
<td><code>numpy.char.replace(&lt;strings&gt;, &lt;string_to_replace&gt;, &lt;replacement&gt;)</code></td>
<td>使用一个新字符串替换一个指定的原字符串中的所有子字符串</td>
</tr>
<tr>
<td><code>numpy.char.encode(&lt;strings&gt;, &lt;encoder&gt;)</code></td>
<td>对元素进行编码（默认编码为 <code>uft-8</code> ）</td>
</tr>
<tr>
<td><code>numpy.char.encode(&lt;strings&gt;, &lt;decoder&gt;)</code></td>
<td>对元素进行解码（默认解码为 <code>uft-8</code> ）</td>
</tr>
</tbody></table>
<h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>numpy.add()</code></td>
<td>加法</td>
</tr>
<tr>
<td><code>numpy.subtract()</code></td>
<td>减法</td>
</tr>
<tr>
<td><code>numpy.multiply()</code></td>
<td>乘法</td>
</tr>
<tr>
<td><code>numpy.divide()</code></td>
<td>除法</td>
</tr>
<tr>
<td><code>numpy.reciprocal()</code></td>
<td>取倒数</td>
</tr>
<tr>
<td><code>numpy.power()</code></td>
<td>取幂</td>
</tr>
<tr>
<td><code>numpy.mod()</code></td>
<td>取余</td>
</tr>
<tr>
<td><code>numpy.dot()</code></td>
<td>数组点积</td>
</tr>
<tr>
<td><code>numpy.vdot()</code></td>
<td>向量点积</td>
</tr>
<tr>
<td><code>numpy.inner()</code></td>
<td>数组内积</td>
</tr>
<tr>
<td><code>numpy.matmul()</code></td>
<td>矩阵积</td>
</tr>
<tr>
<td><code>numpy.sin()</code></td>
<td>正弦函数</td>
</tr>
<tr>
<td><code>numpy.cos()</code></td>
<td>余弦函数</td>
</tr>
<tr>
<td><code>numpy.tan()</code></td>
<td>正切函数</td>
</tr>
<tr>
<td><code>numpy.arctan()</code></td>
<td>反正弦函数</td>
</tr>
<tr>
<td><code>numpy.arccos()</code></td>
<td>反余弦函数</td>
</tr>
<tr>
<td><code>numpy.arctan()</code></td>
<td>反正切函数</td>
</tr>
<tr>
<td><code>numpy.degrees()</code></td>
<td>弧度转角度</td>
</tr>
<tr>
<td><code>numpy.around(&lt;number&gt;, &lt;decimals&gt;)</code></td>
<td>四舍五入</td>
</tr>
<tr>
<td><code>numpy.floor()</code></td>
<td>向下取整</td>
</tr>
<tr>
<td><code>numpy.ceil()</code></td>
<td>向上取整</td>
</tr>
</tbody></table>
<ul>
<li><code>&lt;decimals&gt;</code>指定舍入的小数位数，缺省为 0 ，若为负数则将整数四舍五入至小数点左侧</li>
<li>执行运算前各运算元素须具有相同形状或符合数组广播规则</li>
</ul>
<p><strong>两个数组的点积</strong><br><code>numpy.dot(&lt;ndarrays&gt;, &lt;out&gt;)</code></p>
<ul>
<li><code>&lt;ndarrays&gt;</code>若为一维数组，结果为两数组的内积；若为二维数组，结果为两数组的矩阵乘积；若为多维数组，结果为数组最后一维上所有元素与另一数组倒数第二维上所有元素的乘积之和</li>
<li><code>&lt;out&gt;</code>存储计算结果</li>
</ul>
<p><strong>两个向量的点积</strong><br><code>numpy.vdot(&lt;ndarrays&gt;)</code></p>
<ul>
<li><code>&lt;ndarrays&gt;</code>中第一个参数若为复数，则其共轭复数会被用于计算；若为多维数组，则会被展开</li>
</ul>
<p><strong>一维数组的向量内积</strong><br><code>numpy.inner(&lt;ndarrays&gt;)</code></p>
<ul>
<li><code>&lt;ndarrays&gt;</code>若维度大于 1 ，则返回沿最后一个轴的矩阵乘积</li>
</ul>
<p><strong>两个数组的矩阵乘积</strong><br><code>numpy.matmul(&lt;ndarrays&gt;)</code></p>
<ul>
<li><code>&lt;ndarrays&gt;</code>若为二维数组，则结果为矩阵乘法；若任意数组的维数大于 2 ，则将其视作存在于最后两个索引的矩阵的栈，并进行相应广播；若任意数组为一维数组，则将其维度加 1 变为矩阵，乘法结束后去除</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line">y = np.array([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.dot(x, y))  <span class="comment"># [[19, 22], [43, 50]](矩阵乘积)</span></span><br><span class="line"><span class="built_in">print</span>(np.vdot(x, y))  <span class="comment"># 70（矩阵内积）</span></span><br><span class="line"><span class="built_in">print</span>(np.inner(x, y))  <span class="comment"># [[17, 23], [39, 53]]</span></span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">1</span>+<span class="number">2j</span>, <span class="number">3</span>+<span class="number">4j</span>])</span><br><span class="line">b = np.array([<span class="number">5</span>+<span class="number">6j</span>, <span class="number">7</span>+<span class="number">8j</span>])</span><br><span class="line"><span class="built_in">print</span>(np.vdot(a, b))  <span class="comment"># (70-8j)</span></span><br><span class="line"><span class="built_in">print</span>(np.vdot(b, a))  <span class="comment"># (70+8j)</span></span><br></pre></td></tr></table></figure>

<p><strong>计算输入矩阵的行列式的值</strong><br><code>numpy.linalg.det(&lt;ndarrays&gt;)</code></p>
<p><strong>计算矩阵形式的线性方程的解</strong><br><code>numpy.linalg.solve(&lt;ndarray_formula&gt;, &lt;ndarray_result&gt;)</code></p>
<ul>
<li><code>&lt;ndarray_formula&gt;</code>为线性方程未知数部分的参数</li>
<li><code>&lt;ndarray_result&gt;</code>为线性方程组结果</li>
</ul>
<p><strong>计算矩阵的逆矩阵</strong><br><code>numpy.linalg.inv(&lt;ndarray&gt;)</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">4</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line">b = np.array([<span class="number">2</span>, <span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(np.linalg.det(a))  <span class="comment"># -2.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#计算线性方程组 4x+3y=2, 2x+y=4 的结果</span></span><br><span class="line"><span class="built_in">print</span>(np.linalg.solve(a, b))  <span class="comment">#[5, -6](x==5, y==-6)</span></span><br><span class="line"></span><br><span class="line">c = np.linalg.inv(a)  <span class="comment"># [[-0.5, 1.5], [ 1., -2.]]</span></span><br><span class="line"><span class="built_in">print</span>(np.dot(a, c))  <span class="comment"># [[1., 0.], [0., 1.]]</span></span><br></pre></td></tr></table></figure>

<h1 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h1><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>numpy.amin(&lt;array&gt;, &lt;axis&gt;)</code></td>
<td>数组元素沿指定轴的最小值</td>
</tr>
<tr>
<td><code>numpy.amax(&lt;array&gt;, &lt;axis&gt;)</code></td>
<td>数组元素沿指定轴的最大值</td>
</tr>
<tr>
<td><code>numpy.ptp(&lt;array&gt;, &lt;axis&gt;)</code></td>
<td>数组沿指定轴的极差</td>
</tr>
<tr>
<td><code>numpy.percentile(&lt;array&gt;, &lt;percentage&gt;, &lt;axis&gt;)</code></td>
<td>数组指定百分位沿指定轴的分位数</td>
</tr>
<tr>
<td><code>numpy.median(&lt;array&gt;, &lt;axis&gt;)</code></td>
<td>数组沿指定轴的中位数</td>
</tr>
<tr>
<td><code>numpy.mean(&lt;array&gt;, &lt;axis&gt;)</code></td>
<td>数组沿指定轴的平均数</td>
</tr>
<tr>
<td><code>numpy.average(&lt;array&gt;, &lt;weight&gt;, &lt;axis&gt;)</code></td>
<td>根据另一数组中所给权重计算数组中元素的加权平均值</td>
</tr>
<tr>
<td><code>numpy.std(&lt;array&gt;, &lt;axis&gt;)</code></td>
<td>数组沿指定轴的标准差</td>
</tr>
<tr>
<td><code>numpy.var(&lt;array&gt;, &lt;axis&gt;)</code></td>
<td>数组沿指定轴的方差</td>
</tr>
</tbody></table>
<ul>
<li><code>numpy.average()</code>方法在不给定<code>&lt;weight&gt;</code>时相当于<code>numpy.mean()</code>方法，</li>
<li>在未指定<code>&lt;axis&gt;</code>时上述方法将展开数组</li>
</ul>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p><strong>返回数组排序后的副本</strong><br><code>numpy.sort(&lt;array&gt;, &lt;axis&gt;, &lt;sort_approach&gt;, &lt;order&gt;)</code></p>
<ul>
<li><code>&lt;array&gt;</code>为需要排序的数组</li>
<li><code>&lt;axis&gt;</code>指定排序所沿的轴</li>
<li><code>&lt;kind&gt;</code>指定排序方法<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&#39;quicksort&#39;</code></td>
<td>快速排序</td>
</tr>
<tr>
<td><code>&#39;mergesort&#39;</code></td>
<td>归并排序</td>
</tr>
<tr>
<td><code>&#39;heapsort&#39;</code></td>
<td>堆排序</td>
</tr>
</tbody></table>
</li>
<li><code>&lt;order&gt;</code>指定所排序的字段</li>
</ul>
<p><strong>返回数组内从小到大的数组值的索引值</strong><br><code>numpy.argsort(&lt;array&gt;, &lt;axis&gt;)</code></p>
<p><strong>同时对多个序列排序并返回排序结果中各元素在原数组中对应的索引值</strong><br><code>numpy.lexsort(&lt;arrays&gt;)</code></p>
<p><strong>沿列排序</strong><br><code>numpy.msort(&lt;array&gt;)</code></p>
<ul>
<li>相当于<code>np.sort()</code>方法中<code>&lt;axis&gt;</code>值为 0</li>
</ul>
<p><strong>以先实部后虚部的顺序对复数排序</strong><br><code>numpy.sort_complex(&lt;array&gt;)</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">data = np.dtype([(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;S10&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="built_in">int</span>)])</span><br><span class="line">stu = np.array([(<span class="string">&#x27;Dylan&#x27;</span>, <span class="number">17</span>), (<span class="string">&#x27;Alice&#x27;</span>, <span class="number">16</span>), (<span class="string">&#x27;Frank&#x27;</span>, <span class="number">18</span>)], dtype=data)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.sort(stu, order=<span class="string">&#x27;age&#x27;</span>))  <span class="comment">#按age排序</span></span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>])</span><br><span class="line">y = np.argsort(x)</span><br><span class="line"><span class="built_in">print</span>(x[y])  <span class="comment"># 重构数组</span></span><br><span class="line"></span><br><span class="line">name = [[<span class="string">&#x27;Dylan&#x27;</span>], [<span class="string">&#x27;Alice&#x27;</span>], [<span class="string">&#x27;Frank&#x27;</span>]]</span><br><span class="line">cls = [[<span class="string">&#x27;A&#x27;</span>], [<span class="string">&#x27;B&#x27;</span>], [<span class="string">&#x27;A&#x27;</span>]]</span><br><span class="line"><span class="built_in">print</span>(np.lexsort((cls, name)), end=<span class="string">&#x27;\n\n&#x27;</span>) <span class="comment">#排序索引结果</span></span><br><span class="line"><span class="built_in">print</span>([name[i] + <span class="string">&#x27;,&#x27;</span> + cls[i] <span class="keyword">for</span> i <span class="keyword">in</span> cls]) <span class="comment">#排序结果</span></span><br></pre></td></tr></table></figure>

<p><strong>挑选指定数组中最小的几个元素置于数组最前端，并与其他元素分为两堆</strong><br><code>numpy.partition(&lt;array&gt;, &lt;kth&gt;, &lt;axis&gt;)</code></p>
<ul>
<li>新数组中前<code>&lt;count&gt;</code>个元素为原数组中最小的<code>&lt;count&gt;</code>个元素</li>
<li>仅将最小的<code>&lt;count&gt;</code>个元素置于数组最前端，不需要完整排序（类似快速排序过程）</li>
<li>返回分区后的新数组</li>
</ul>
<p><strong>挑选指定数组中最小的几个元素置于数组最前端，并与其他元素分为两堆</strong><br><code>numpy.argpartition(&lt;array&gt;, &lt;kth&gt;, &lt;axis&gt;)</code></p>
<ul>
<li>与<code>numpy.partition()</code>的主要功能相同</li>
<li>返回分区后的新数组内元素在原数组中的索引号</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([<span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>, -<span class="number">4</span>, -<span class="number">3</span>, -<span class="number">6</span>, -<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(np.partition(arr, kth=<span class="number">4</span>))  <span class="comment"># [-6, -4, -3, -1, 1, 4, 7, 5, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回数组中最小的3个数字</span></span><br><span class="line"><span class="built_in">print</span>(np.partition(arr, kth=<span class="number">3</span>)[:<span class="number">3</span>], end=<span class="string">&#x27;\n\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(arr[np.argpartition(arr, kth=<span class="number">3</span>)[:<span class="number">3</span>]])</span><br><span class="line"><span class="comment"># [-6, -4, -3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回数组中最大的5个数字</span></span><br><span class="line"><span class="built_in">print</span>(np.partition(arr, kth=-<span class="number">5</span>)[-<span class="number">5</span>:], end=<span class="string">&#x27;\n\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(arr[np.argpartition(arr, kth=-<span class="number">5</span>)[-<span class="number">5</span>:]])</span><br><span class="line"><span class="comment"># [1, 4, 7, 5, 9]</span></span><br></pre></td></tr></table></figure>

<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><p><strong>将数组保存到以 .npy 为扩展名的文件中</strong><br><code>numpy.save(&lt;fname&gt;, &lt;array&gt;, &lt;allow_pickle&gt;, &lt;fix_imports&gt;)</code></p>
<ul>
<li><code>&lt;fname&gt;</code>为需要保存的文件名</li>
<li><code>&lt;array&gt;</code>为需要保存的数组</li>
<li><code>&lt;allow_pickle&gt;</code>允许使用Python pickles保存对象数组，Python中的pickle用于在保存到磁盘文件或从磁盘文件读取之前，对对象进行序列化和反序列化，默认为<code>False</code></li>
<li><code>&lt;fix_imports&gt;</code>方便从Pyhton2中读取Python3中保存的数据，默认为<code>True</code></li>
</ul>
<p><strong>读取 .npy 文件</strong></p>
<p><code>numpy.load(&lt;fname&gt;, &lt;allow_pickle&gt;, &lt;fix_imports&gt;)</code></p>
<ul>
<li><code>&lt;fname&gt;</code>为需要保存的文件名</li>
<li><code>&lt;allow_pickle&gt;</code>允许使用Python pickles读取对象数组，默认为<code>False</code></li>
<li><code>&lt;fix_imports&gt;</code>方便从Python2中读取Python3中保存的数据，默认为<code>True</code></li>
</ul>
<p><strong>将多个数组保存到以 .npz 为扩展名的文件中</strong><br><code>numpy.savez(&lt;fname&gt;, *args, **kwds)</code></p>
<ul>
<li><code>&lt;fname&gt;</code>为需要保存的文件名</li>
<li><code>*args</code>为需要保存的数组，可以使用关键字参数为数组命名，否则数组会自动命名为 arr_0, arr_1, …</li>
<li><code>**kwds</code>为需要保存的数组使用的关键字名称</li>
</ul>
<p><strong>以简单的文本文件格式存储数据</strong><br><code>np.savetxt(&lt;fname&gt;, &lt;array&gt;, &lt;fmt&gt;, &lt;delimiter&gt;)</code></p>
<ul>
<li><code>&lt;fname&gt;</code>为需要保存的文件名</li>
<li><code>&lt;array&gt;</code>为需要保存的数组</li>
<li><code>&lt;fmt&gt;</code>指定存储数据类型，默认为’%.18e’</li>
<li><code>&lt;delimiter&gt;</code>指定元素之间的分隔符，默认为空格</li>
</ul>
<p><strong>读取 .txt 文件</strong><br><code>np.loadtxt(&lt;fname&gt;, &lt;dtype&gt;, &lt;delimiter&gt;)</code></p>
<ul>
<li><code>&lt;fname&gt;</code>为需要读取的文件名</li>
<li><code>&lt;dtype&gt;</code>指定读取所返回的数据类型，默认为<code>float</code></li>
<li><code>&lt;delimiter&gt;</code>指定读取的分隔符，默认无分隔符</li>
</ul>
<h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><p>自 1.19.0 版本后Numpy官方已不推荐引用<code>numpy.matlib</code>方法，同时不推荐通过矩阵类表示矩阵或处理线性代数问题(见 <a target="_blank" rel="noopener" href="https://docs.scipy.org/doc/numpy/user/numpy-for-matlab-users">https://docs.scipy.org/doc/numpy/user/numpy-for-matlab-users</a>) ，建议使用常规<code>Ndarray</code>类。</p>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2022/10/11/Python_Pandas/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>Prev</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
              2022-10-14 17:52:51
            </span>
            
                  <span class="post-tags">
                    <i class="iconfont icon-tags mr-10" title="Tags"></i>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/python/" title="python">
                        #python
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2022/10/19/Python_view_and_copy/" target="_self">
                <span>Next</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">Contents</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%B1%9E%E6%80%A7"><span class="toc-text">数组属性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#dtype"><span class="toc-text">dtype</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84"><span class="toc-text">创建数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%87%E7%89%87%E4%B8%8E%E7%B4%A2%E5%BC%95"><span class="toc-text">切片与索引</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95"><span class="toc-text">整数数组索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E7%B4%A2%E5%BC%95"><span class="toc-text">布尔索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8A%B1%E5%BC%8F%E7%B4%A2%E5%BC%95"><span class="toc-text">花式索引</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%BF%E6%92%AD"><span class="toc-text">广播</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C"><span class="toc-text">数组操作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-text">位运算</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6"><span class="toc-text">数学</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1"><span class="toc-text">统计</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-text">排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6"><span class="toc-text">文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5"><span class="toc-text">矩阵</span></a></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          <a title="github" target="_blank" rel="noopener" href="https://github.com/zielorem">
            <i class="iconfont icon-github"></i>
          </a>
        </li>
      
        <li>
          <a title="twitter" target="_blank" rel="noopener" href="https://twitter.com/zielorem">
            <i class="iconfont icon-twitter"></i>
          </a>
        </li>
      
        <li>
          <a title="weibo" target="_blank" rel="noopener" href="https://weibo.com/u/6297064983">
            <i class="iconfont icon-weibo"></i>
          </a>
        </li>
      
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zielorem">Copyright © 2023 Zielorem</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="search for...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>First search, index file loading, please wait...<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>No result<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The search.xml file was not found, please refer to：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The request failed, Try to refresh the page or try again later.<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + Numpy%E5%BA%93%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95 + '&url=' + http%3A%2F%2Fexample.com%2F2022%2F10%2F14%2FPython_Numpy%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=http://example.com/2022/10/14/Python_Numpy/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 3,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(e){e.imageLazyLoadSetting.processImages=t;var n=e.imageLazyLoadSetting.isSPA,i=e.imageLazyLoadSetting.preloadRatio||1,r=o();function o(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){n&&(r=o());for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(e.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var t,e,n,i,o=r[a];e=function(){r=r.filter(function(t){return o!==t})},(t=o).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,t.removeAttribute("data-original"),e&&e()},t.src!==i&&(n.src=i))}()}function a(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",a),e.addEventListener("resize",a),e.addEventListener("orientationchange",a)}(this);</script></body>
</html>
